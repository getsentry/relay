use relay_event_schema::protocol::Span;

/// Generate an OpenTelemetry-compliant span name from a Sentry span.
///
/// Sentry's SDKs gather a lot more telemetry than OpenTelemetry's SDKs, so many Sentry spans do not
/// have corresponding OpenTelemetry conventions. In these cases, we're making a best-effort attempt
/// to create a useful low-cardinality name.
///
/// NOTE: Ideally, if `sentry-conventions` also documented the conventions for span names, this
/// function could comply with those conventions.
///
/// # Examples
///
/// ```
/// use relay_event_schema::protocol::{Span, SpanData};
/// use relay_protocol::{Annotated, Value};
/// use sentry_to_otel::name_for_span;
///
/// let mut span = Span::default();
/// span.op = Annotated::new("db.query".to_owned());
/// let mut data = SpanData::default();
/// data.db_operation = Annotated::new(Value::String("SELECT".to_owned()));
/// data.db_collection_name = Annotated::new(Value::String("users".to_owned()));
/// span.data = Annotated::new(data);
/// let name = sentry_to_otel_name(&span);
/// assert_eq!(name, "SELECT users");
/// ```
pub fn name_for_span(span: &Span) -> String {
    let op = span.op.value().map(|s| s.as_str()).unwrap_or("default");
    let parts: Vec<&str> = op.split('.').collect();
    let category = parts.first().unwrap_or(&"default");
    let action = parts.get(1).copied();

    let data = span.data.value();

    // https://develop.sentry.dev/sdk/telemetry/traces/span-operations/ supplied the list of
    // categories, but it doesn't appear to be exhaustive. Logic for generating the names is taken
    // from existing implementation in the Python and JavaScript SDKs, with a best-effort attempt to
    // comply with OpenTelemetry conventions. Efforts to fully document and standardize these names
    // are ongoing.
    match *category {
        "ai" => name_for_ai_span(op),
        "app" => name_for_app_span(op),
        "browser" => name_for_browser_span(action),
        "cache" => name_for_cache_span(action, op),
        "console" => op.to_owned(), // Describes usage of console like `rails console`
        "db" => name_for_database_span(data, op),
        "event" => name_for_event_span(action),
        "file" => name_for_file_span(action),
        "function" => name_for_function_span(data), // Manual functions as well as FAAS
        "gen_ai" => op.to_owned(), // Deprecated
        "graphql" => name_for_graphql_span(action),
        "grpc" => name_for_grpc_span(action),
        "http" => name_for_http_span(data, op),
        "mark" => op.to_owned(), // These are 0-duration spans generated by browser SDKs
        "measure" => op.to_owned(), // These are 0-duration spans generated by browser SDKs
        "middleware" => String::from("Middleware"),
        "navigation" => String::from("Navigation"), // OTLP has no support for this, and therefore no opinion
        "pageload" => String::from("Pageload"),  // OTLP has no support for this, and therefore no opinion
        "queue" => name_for_queue_span(action),
        "resource" => name_for_resource_span(action, op),
        "rpc" => String::from("RPC"), // Unclear if any SDKs make these
        "serialize" => String::from("Serialization"), // Loose convention, but SDKs create these spans
        "socket" => name_for_socket_span(),
        "subprocess" => name_for_subprocess_span(action),
        "template" => String::from("Template render"), // Unclear if there are other varieties
        "topic" => name_for_topic_span(data, op), // Unclear if SDKs make these, and how
        "ui" => name_for_ui_span(data, action, op),
        "view" => String::from("View render"),
        "websocket" => String::from("Websocket"), // Unclear if any SDKs make these
        _ => op.to_owned(),
    }
}

fn name_for_ai_span(op: &str) -> String {
        match op {
            "ai.messages.create.anthropic" => String::from("Anthropic messages create"),

            "ai.chat_completions.create.cohere" => String::from("cohere.client.Chat"),
            "ai.chat_completions.create.openai" => String::from("Chat Completion"),
            "ai.chat_completions.create.langchain" => String::from("Langchain Chat Model")
            "ai.chat_completions.create.huggingface_hub" => String::from("Text Generation"),

            "ai.embeddings.create.cohere" => String::from("Cohere Embedding Creation"),
            "ai.embeddings.create.openai" => String::from("OpenAI Embedding Creation"),

           "ai.pipeline.langchain" => String::from("Chain execution"),

           "ai.run.langchain" => String::from("Chain execution"),
           "ai.tool.langchain" => String::from("AI tool usage"),
           "ai.agent.langchain" => String::from("AI tool usage"),

           _ => op.to_owned()
        }

}

fn name_for_app_span(op: &str) -> String {
    match op {
        "app.bootstrap" => String::from("App bootstrap"),
        "app.php.autoload" => String::from("App PHP autoload"),
        "app.start" => String::from("App start"),
        "app.start.warm" => String::from("App warm start"),
        "app.start.cold" => String::from("App cold start"),
       _ => op.to_owned()
    }
}

fn name_for_browser_span(action: Option<&str>) -> String {
    match action {
        None => return String::from("Browser"),
        Some(action) => format!("Browser {action}")
    }
}

fn name_for_cache_span(action: Option<&str>, op: &str) -> String {
    action
        .map(|a| a.to_uppercase())
        .unwrap_or_else(|| op.to_owned())
}


fn name_for_database_span(data: Option<&relay_event_schema::protocol::SpanData>, op: &str) -> String {
    let data = match data {
        Some(d) => d,
        None => return op.to_owned(),
    };

    let operation = data.db_operation.value().and_then(|v| v.as_str());
    let collection = data.db_collection_name.value().and_then(|v| v.as_str());
    let db_system = data.db_system.value().and_then(|v| v.as_str());

    match (operation, collection) {
        (Some(op), Some(coll)) => format!("{} {}", op.to_uppercase(), coll),
        (Some(op), None) => op.to_uppercase(),
        (None, Some(coll)) => coll.to_owned(),
        (None, None) => db_system.unwrap_or(op).to_owned(),
    }
}

fn name_for_event_span(action: Option<&str>) -> String {
    match action {
        Some(action) => match action {
            "django" => String::from("Django event"),
            _ => String::from("Event"),
        },
        None => String::from("Event"),
    }
}

fn name_for_file_span(action: Option<&str>) -> String {
    match action {
        Some(action) => match action {
            "read" => String::from("File read"),
            "write" => String::from("File write"),
            "copy" => String::from("File copy"),
            "delete" => String::from("File delete"),
            "open" => String::from("File open"),
            "rename" => String::from("File rename"),
            _ => String::from("File operation"),
        },
        None => String::from("File operation"),
    }
}

fn name_for_function_span(data: Option<&relay_event_schema::protocol::SpanData>) -> String {
    let data = match data {
        Some(d) => d,
        None => return String::from("Function"),
    };

    let function_name = data
        .code_function
        .value()
        .and_then(|v| v.as_str())

    match function_name {
        Some(function_name) => format!("Function {function_name}"),
        None => String::from("Function"),
    }

}

fn name_for_graphql_span(action: Option<&str>) -> String {

        match action {
            Some(action) => match action {
            "execute" => format!("GraphQL {action}"),
            "mutation" => format!("GraphQL {action}"),
            "parse" => format!("GraphQL {action}"),
            "resolve" => format!("GraphQL {action}"),
            "subscription" => format!("GraphQL {action}"),
            "query" => format!("GraphQL {action}"),
            "validate" => format!("GraphQL {action}"),
            _ => String::from("GraphQL")
        },
        None => String::from("GraphQL")
        }
}

fn name_for_grpc_span(action: Option<&str>) -> String {

        match action {
            Some(action) => match action {
            "client" => format!("gRPC {action}"),
            "server" => format!("gRPC {action}"),
            _ => String::from("gRPC")
        },
        None => String::from("gRPC")
        }
}

fn name_for_http_span(data: Option<&relay_event_schema::protocol::SpanData>, op: &str) -> String {
    let data = match data {
        Some(d) => d,
        None => return op.to_owned(),
    };

    // TODO: It would be safer to check whether the method is a valid HTTP method
    let method = data
        .http_request_method
        .value()
        .and_then(|v| v.as_str())
        .unwrap_or("HTTP");

    // TODO: Here, we should use the route from the description, since it's probably safe
    method.to_uppercase()
}

fn name_for_queue_span(action: Option<&str>) -> String {
    match action {
        Some(action) => match action {
            "process" => String::from("Queue processing"),
            "publish" => String::from("Queue publish"),
            "submit" => String::from("Queue submit"),
            "task" => String::from("Queue task"),
        }
        None => String::from("queue"),
    }
}

fn name_for_resource_span(action: Option<&str>, op: &str) -> String {
    match action {
        Some(resource_type) => format!("resource.{resource_type}"),
        None => op.to_owned(),
    }
}

fn name_for_socket_span() -> String {
    // TODO: This is silly
    String::from("Socket connection");
}

fn name_for_subprocess_span(action: Option<&str>) -> String {
    match action {
        Some(action) => format!("Subprocess {action}"),
        None => String::from("Subprocess"),
    }
}

fn name_for_ui_span(
    data: Option<&relay_event_schema::protocol::SpanData>,
    action: Option<&str>,
    op: &str,
) -> String {
    let data = match data {
        Some(d) => d,
        None => return op.to_owned(),
    };

    // Try to get component name for UI operations
    let component = data.ui_component_name.value().and_then(|v| v.as_str());

    match (action, component) {
        (Some(action), Some(component)) => format!("{action} {component}"),
        (Some(action), None) => action.to_owned(),
        (None, Some(_)) => op.to_owned(), // Keep original if no action
        (None, None) => op.to_owned(),
    }
}

fn name_for_topic_span(
    data: Option<&relay_event_schema::protocol::SpanData>,
    op: &str,
) -> String {
    let data = match data {
        Some(d) => d,
        None => return op.to_owned(),
    };

    let operation = data.messaging_operation_type.value().map(|s| s.as_str());
    let destination = data.messaging_destination_name.value().map(|s| s.as_str());

    match (operation, destination) {
        (Some(operation), Some(destination)) => format!("{operation} {destination}"),
        (Some(operation), None) => operation.to_owned(),
        (None, Some(destination)) => destination.to_owned(),
        (None, None) => op.to_owned(),
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use relay_event_schema::protocol::SpanData;
    use relay_protocol::{Annotated, Value};

    fn annotated_string(value: &str) -> Annotated<Value> {
        Annotated::new(Value::String(value.to_owned()))
    }

    fn annotated_str(value: &str) -> Annotated<String> {
        Annotated::new(value.to_owned())
    }

    fn create_span_with_op(op: &str) -> Span {
        Span {
            op: annotated_str(op),
            ..Default::default()
        }
    }

    fn create_span_with_op_and_data(op: &str, data: SpanData) -> Span {
        let mut span = create_span_with_op(op);
        span.data = Annotated::new(data);
        span
    }

    #[test]
    fn test_database_with_operation_and_collection() {
        let data = SpanData {
            db_operation: annotated_string("SELECT"),
            db_collection_name: annotated_string("users"),
            ..Default::default()
        };
        let span = create_span_with_op_and_data("db.query", data);
        assert_eq!(name_for_span(&span), "SELECT users");
    }

    #[test]
    fn test_database_with_operation() {
        let data = SpanData {
            db_operation: annotated_string("INSERT"),
            ..Default::default()
        };
        let span = create_span_with_op_and_data("db.query", data);
        assert_eq!(name_for_span(&span), "INSERT");
    }

    #[test]
    fn test_database_with_collection() {
        let data = SpanData {
            db_collection_name: annotated_string("posts"),
            ..Default::default()
        };
        let span = create_span_with_op_and_data("db.query", data);
        assert_eq!(name_for_span(&span), "posts");
    }

    #[test]
    fn test_database_with_system() {
        let data = SpanData {
            db_system: annotated_string("postgresql"),
            ..Default::default()
        };
        let span = create_span_with_op_and_data("db.query", data);
        assert_eq!(name_for_span(&span), "postgresql");
    }

    #[test]
    fn test_database_redis() {
        let data = SpanData {
            db_operation: annotated_string("GET"),
            db_system: annotated_string("redis"),
            ..Default::default()
        };
        let span = create_span_with_op_and_data("db.redis", data);
        assert_eq!(name_for_span(&span), "GET");
    }

    #[test]
    fn test_http_client_method() {
        let data = SpanData {
            http_request_method: annotated_string("POST"),
            ..Default::default()
        };
        let span = create_span_with_op_and_data("http.client", data);
        assert_eq!(name_for_span(&span), "POST");
    }

    #[test]
    fn test_redis_operation_and_system() {
        let data = SpanData {
            db_operation: annotated_string("GET"),
            db_system: annotated_string("redis"),
            ..Default::default()
        };
        let span = create_span_with_op_and_data("db.redis", data);
        assert_eq!(name_for_span(&span), "GET");
    }

    #[test]
    fn test_redis_operation() {
        let data = SpanData {
            db_operation: annotated_string("SET"),
            db_system: annotated_string("redis"),
            ..Default::default()
        };
        let span = create_span_with_op_and_data("db.redis", data);
        assert_eq!(name_for_span(&span), "SET");
    }

    #[test]
    fn test_browser_resource_loads() {
        let span = create_span_with_op("resource.script");
        assert_eq!(name_for_span(&span), "resource.script");

        let span = create_span_with_op("resource.css");
        assert_eq!(name_for_span(&span), "resource.css");

        let span = create_span_with_op("resource.img");
        assert_eq!(name_for_span(&span), "resource.img");

        let span = create_span_with_op("resource");
        assert_eq!(name_for_span(&span), "resource");
    }

    #[test]
    fn test_cache_operations() {
        let span = create_span_with_op("cache.get");
        assert_eq!(name_for_span(&span), "GET");

        let span = create_span_with_op("cache.set");
        assert_eq!(name_for_span(&span), "SET");

        let span = create_span_with_op("cache.delete_item");
        assert_eq!(name_for_span(&span), "DELETE_ITEM");
    }

    #[test]
    fn test_ui_operation_component() {
        // Test UI operation with component
        let data = SpanData {
            ui_component_name: annotated_string("UserProfile"),
            ..Default::default()
        };
        let span = create_span_with_op_and_data("ui.render", data);
        assert_eq!(name_for_span(&span), "render UserProfile");
    }

    #[test]
    fn test_ui_operation() {
        let span = create_span_with_op("ui.action.click");
        assert_eq!(name_for_span(&span), "ui.action.click");
    }

    #[test]
    fn test_messaging_operation_destination() {
        let data = SpanData {
            messaging_operation_type: annotated_str("send"),
            messaging_destination_name: annotated_str("user-events"),
            ..Default::default()
        };
        let span = create_span_with_op_and_data("queue.task", data);
        assert_eq!(name_for_span(&span), "send user-events");
    }

    #[test]
    fn test_messaging_destination() {
        let data = SpanData {
            messaging_destination_name: annotated_str("notifications"),
            ..Default::default()
        };
        let span = create_span_with_op_and_data("topic.process", data);
        assert_eq!(name_for_span(&span), "notifications");
    }

    #[test]
    fn test_graphql_operations() {
        let span = create_span_with_op("graphql.query");
        assert_eq!(name_for_span(&span), "query");

        let span = create_span_with_op("graphql.mutation");
        assert_eq!(name_for_span(&span), "mutation");

        let span = create_span_with_op("graphql.subscription");
        assert_eq!(name_for_span(&span), "subscription");

        let span = create_span_with_op("graphql");
        assert_eq!(name_for_span(&span), "GraphQL Operation");
    }

    #[test]
    fn test_unknown_operations() {
        let span = create_span_with_op("custom.operation");
        assert_eq!(name_for_span(&span), "custom.operation");

        let span = create_span_with_op("function");
        assert_eq!(name_for_span(&span), "function");
    }

    #[test]
    fn test_no_operation() {
        let span = Span::default();
        assert_eq!(name_for_span(&span), "default");
    }
}
