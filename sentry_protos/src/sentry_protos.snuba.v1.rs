// This file is @generated by prost-build.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AttributeKey {
    #[prost(enumeration = "attribute_key::Type", tag = "1")]
    pub r#type: i32,
    /// the name of the trace item attribute, everything that sentry sends by default is prefixed with
    /// `sentry.` to allow users to send attributes of the same name.
    /// Exampe: `sentry.duration`, `sentry.span_id` etc
    #[prost(string, tag = "2")]
    pub name: ::prost::alloc::string::String,
}
/// Nested message and enum types in `AttributeKey`.
pub mod attribute_key {
    /// this mostly reflects what types are able to be ingested, see eap_spans consumer for ingest details
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
    #[repr(i32)]
    pub enum Type {
        /// protobuf requirement, do not send this
        Unspecified = 0,
        String = 1,
        Boolean = 2,
        /// deprecated, use TYPE_DOUBLE instead
        Float = 3,
        /// note: all numbers are stored as float64, so massive integers can be rounded. USE STRING FOR IDS.
        Int = 4,
        Double = 5,
    }
    impl Type {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Type::Unspecified => "TYPE_UNSPECIFIED",
                Type::String => "TYPE_STRING",
                Type::Boolean => "TYPE_BOOLEAN",
                Type::Float => "TYPE_FLOAT",
                Type::Int => "TYPE_INT",
                Type::Double => "TYPE_DOUBLE",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "TYPE_UNSPECIFIED" => Some(Self::Unspecified),
                "TYPE_STRING" => Some(Self::String),
                "TYPE_BOOLEAN" => Some(Self::Boolean),
                "TYPE_FLOAT" => Some(Self::Float),
                "TYPE_INT" => Some(Self::Int),
                "TYPE_DOUBLE" => Some(Self::Double),
                _ => None,
            }
        }
    }
}
/// custom mappings of column values
///
/// for example, `project_name` is changeable by the user and not stored in EAP,
/// but sorting by it may be desired. So something like this might be done:
///
/// ORDER BY sentry.project_name
/// VirtualColumnContext(
///    from_column_name="sentry.project_id",
///    to_column_name="sentry.project_name",
///    value_map={"1": "sentry", "2": "snuba"},
/// )
///
/// in this example `sentry.project_name` is a virtual column created by mapping
/// values from the real column `sentry.project_id` to new values. project_id of 1
/// gets mapped to project_name="sentry" etc.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct VirtualColumnContext {
    #[prost(string, tag = "1")]
    pub from_column_name: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub to_column_name: ::prost::alloc::string::String,
    #[prost(map = "string, string", tag = "3")]
    pub value_map:
        ::std::collections::HashMap<::prost::alloc::string::String, ::prost::alloc::string::String>,
    #[prost(string, tag = "4")]
    pub default_value: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct StrArray {
    #[prost(string, repeated, tag = "1")]
    pub values: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct IntArray {
    #[prost(int64, repeated, tag = "1")]
    pub values: ::prost::alloc::vec::Vec<i64>,
}
/// DEPRECATED, use DoubleArray instead
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FloatArray {
    #[prost(float, repeated, tag = "1")]
    pub values: ::prost::alloc::vec::Vec<f32>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DoubleArray {
    #[prost(double, repeated, tag = "1")]
    pub values: ::prost::alloc::vec::Vec<f64>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AttributeValue {
    /// true if the value is null
    #[prost(bool, tag = "11")]
    pub is_null: bool,
    #[prost(
        oneof = "attribute_value::Value",
        tags = "1, 2, 3, 4, 5, 6, 7, 8, 9, 10"
    )]
    pub value: ::core::option::Option<attribute_value::Value>,
}
/// Nested message and enum types in `AttributeValue`.
pub mod attribute_value {
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Value {
        #[prost(bool, tag = "1")]
        ValBool(bool),
        #[prost(string, tag = "2")]
        ValStr(::prost::alloc::string::String),
        /// deprecated, use val_double instead
        #[prost(float, tag = "3")]
        ValFloat(f32),
        #[prost(int64, tag = "4")]
        ValInt(i64),
        /// set to true if value is null
        #[prost(bool, tag = "5")]
        ValNull(bool),
        #[prost(message, tag = "6")]
        ValStrArray(super::StrArray),
        #[prost(message, tag = "7")]
        ValIntArray(super::IntArray),
        /// deprecated, use val_double_array instead
        #[prost(message, tag = "8")]
        ValFloatArray(super::FloatArray),
        #[prost(double, tag = "9")]
        ValDouble(f64),
        #[prost(message, tag = "10")]
        ValDoubleArray(super::DoubleArray),
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AttributeAggregation {
    #[prost(enumeration = "Function", tag = "1")]
    pub aggregate: i32,
    #[prost(message, optional, tag = "2")]
    pub key: ::core::option::Option<AttributeKey>,
    #[prost(string, tag = "3")]
    pub label: ::prost::alloc::string::String,
    #[prost(enumeration = "ExtrapolationMode", tag = "4")]
    pub extrapolation_mode: i32,
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum Function {
    Unspecified = 0,
    Sum = 1,
    Average = 2,
    Count = 3,
    P50 = 4,
    P75 = 12,
    P90 = 5,
    P95 = 6,
    P99 = 7,
    Avg = 8,
    Max = 9,
    Min = 10,
    Uniq = 11,
}
impl Function {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Function::Unspecified => "FUNCTION_UNSPECIFIED",
            Function::Sum => "FUNCTION_SUM",
            Function::Average => "FUNCTION_AVERAGE",
            Function::Count => "FUNCTION_COUNT",
            Function::P50 => "FUNCTION_P50",
            Function::P75 => "FUNCTION_P75",
            Function::P90 => "FUNCTION_P90",
            Function::P95 => "FUNCTION_P95",
            Function::P99 => "FUNCTION_P99",
            Function::Avg => "FUNCTION_AVG",
            Function::Max => "FUNCTION_MAX",
            Function::Min => "FUNCTION_MIN",
            Function::Uniq => "FUNCTION_UNIQ",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "FUNCTION_UNSPECIFIED" => Some(Self::Unspecified),
            "FUNCTION_SUM" => Some(Self::Sum),
            "FUNCTION_AVERAGE" => Some(Self::Average),
            "FUNCTION_COUNT" => Some(Self::Count),
            "FUNCTION_P50" => Some(Self::P50),
            "FUNCTION_P75" => Some(Self::P75),
            "FUNCTION_P90" => Some(Self::P90),
            "FUNCTION_P95" => Some(Self::P95),
            "FUNCTION_P99" => Some(Self::P99),
            "FUNCTION_AVG" => Some(Self::Avg),
            "FUNCTION_MAX" => Some(Self::Max),
            "FUNCTION_MIN" => Some(Self::Min),
            "FUNCTION_UNIQ" => Some(Self::Uniq),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum ExtrapolationMode {
    Unspecified = 0,
    None = 1,
    SampleWeighted = 2,
}
impl ExtrapolationMode {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            ExtrapolationMode::Unspecified => "EXTRAPOLATION_MODE_UNSPECIFIED",
            ExtrapolationMode::None => "EXTRAPOLATION_MODE_NONE",
            ExtrapolationMode::SampleWeighted => "EXTRAPOLATION_MODE_SAMPLE_WEIGHTED",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "EXTRAPOLATION_MODE_UNSPECIFIED" => Some(Self::Unspecified),
            "EXTRAPOLATION_MODE_NONE" => Some(Self::None),
            "EXTRAPOLATION_MODE_SAMPLE_WEIGHTED" => Some(Self::SampleWeighted),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum Reliability {
    Unspecified = 0,
    Low = 1,
    High = 2,
}
impl Reliability {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Reliability::Unspecified => "RELIABILITY_UNSPECIFIED",
            Reliability::Low => "RELIABILITY_LOW",
            Reliability::High => "RELIABILITY_HIGH",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "RELIABILITY_UNSPECIFIED" => Some(Self::Unspecified),
            "RELIABILITY_LOW" => Some(Self::Low),
            "RELIABILITY_HIGH" => Some(Self::High),
            _ => None,
        }
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AndFilter {
    #[prost(message, repeated, tag = "1")]
    pub filters: ::prost::alloc::vec::Vec<TraceItemFilter>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct OrFilter {
    #[prost(message, repeated, tag = "1")]
    pub filters: ::prost::alloc::vec::Vec<TraceItemFilter>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct NotFilter {
    #[prost(message, repeated, tag = "1")]
    pub filters: ::prost::alloc::vec::Vec<TraceItemFilter>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ComparisonFilter {
    #[prost(message, optional, tag = "1")]
    pub key: ::core::option::Option<AttributeKey>,
    #[prost(enumeration = "comparison_filter::Op", tag = "2")]
    pub op: i32,
    #[prost(message, optional, tag = "3")]
    pub value: ::core::option::Option<AttributeValue>,
    /// optional, if set will ignore case for string comparisons
    #[prost(bool, tag = "4")]
    pub ignore_case: bool,
}
/// Nested message and enum types in `ComparisonFilter`.
pub mod comparison_filter {
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
    #[repr(i32)]
    pub enum Op {
        Unspecified = 0,
        LessThan = 1,
        GreaterThan = 2,
        LessThanOrEquals = 3,
        GreaterThanOrEquals = 4,
        Equals = 5,
        NotEquals = 6,
        /// string only
        Like = 7,
        /// string only
        NotLike = 8,
        /// array only
        In = 9,
        /// array only
        NotIn = 10,
    }
    impl Op {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Op::Unspecified => "OP_UNSPECIFIED",
                Op::LessThan => "OP_LESS_THAN",
                Op::GreaterThan => "OP_GREATER_THAN",
                Op::LessThanOrEquals => "OP_LESS_THAN_OR_EQUALS",
                Op::GreaterThanOrEquals => "OP_GREATER_THAN_OR_EQUALS",
                Op::Equals => "OP_EQUALS",
                Op::NotEquals => "OP_NOT_EQUALS",
                Op::Like => "OP_LIKE",
                Op::NotLike => "OP_NOT_LIKE",
                Op::In => "OP_IN",
                Op::NotIn => "OP_NOT_IN",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "OP_UNSPECIFIED" => Some(Self::Unspecified),
                "OP_LESS_THAN" => Some(Self::LessThan),
                "OP_GREATER_THAN" => Some(Self::GreaterThan),
                "OP_LESS_THAN_OR_EQUALS" => Some(Self::LessThanOrEquals),
                "OP_GREATER_THAN_OR_EQUALS" => Some(Self::GreaterThanOrEquals),
                "OP_EQUALS" => Some(Self::Equals),
                "OP_NOT_EQUALS" => Some(Self::NotEquals),
                "OP_LIKE" => Some(Self::Like),
                "OP_NOT_LIKE" => Some(Self::NotLike),
                "OP_IN" => Some(Self::In),
                "OP_NOT_IN" => Some(Self::NotIn),
                _ => None,
            }
        }
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ExistsFilter {
    #[prost(message, optional, tag = "1")]
    pub key: ::core::option::Option<AttributeKey>,
}
/// a condition used to filter for matching "trace items"
///
/// ex: "exists span.duration" would mean
/// "only give me trace items that have the attribute 'span.duration'"
///
/// ( traces contain trace items,
///    eg. trace items are: span, replay, error, etc,
///    trace items contain attributes like 'span.duration' )
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TraceItemFilter {
    #[prost(oneof = "trace_item_filter::Value", tags = "1, 2, 3, 4, 5")]
    pub value: ::core::option::Option<trace_item_filter::Value>,
}
/// Nested message and enum types in `TraceItemFilter`.
pub mod trace_item_filter {
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Value {
        #[prost(message, tag = "1")]
        AndFilter(super::AndFilter),
        #[prost(message, tag = "2")]
        OrFilter(super::OrFilter),
        #[prost(message, tag = "3")]
        NotFilter(super::NotFilter),
        #[prost(message, tag = "4")]
        ComparisonFilter(super::ComparisonFilter),
        #[prost(message, tag = "5")]
        ExistsFilter(super::ExistsFilter),
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AttributeConditionalAggregation {
    #[prost(enumeration = "Function", tag = "1")]
    pub aggregate: i32,
    #[prost(message, optional, tag = "2")]
    pub key: ::core::option::Option<AttributeKey>,
    #[prost(string, tag = "3")]
    pub label: ::prost::alloc::string::String,
    #[prost(enumeration = "ExtrapolationMode", tag = "4")]
    pub extrapolation_mode: i32,
    #[prost(message, optional, tag = "5")]
    pub filter: ::core::option::Option<TraceItemFilter>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct DownsampledStorageConfig {
    #[prost(enumeration = "downsampled_storage_config::Mode", tag = "1")]
    pub mode: i32,
}
/// Nested message and enum types in `DownsampledStorageConfig`.
pub mod downsampled_storage_config {
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
    #[repr(i32)]
    pub enum Mode {
        Unspecified = 0,
        /// deprecated, treated as NORMAL mode
        Preflight = 1,
        /// deprecated, treated as NORMAL mode
        BestEffort = 2,
        /// NORMAL queries are served faster and should not time out
        /// EAP will route to whatever tier it needs to in order to facilitate this
        /// The return payload from EAP will inform the client if there is a higher fidelity tier to scan
        Normal = 3,
        /// HIGHEST_ACCURACY queries go straight to tier 1
        HighestAccuracy = 4,
    }
    impl Mode {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Mode::Unspecified => "MODE_UNSPECIFIED",
                Mode::Preflight => "MODE_PREFLIGHT",
                Mode::BestEffort => "MODE_BEST_EFFORT",
                Mode::Normal => "MODE_NORMAL",
                Mode::HighestAccuracy => "MODE_HIGHEST_ACCURACY",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "MODE_UNSPECIFIED" => Some(Self::Unspecified),
                "MODE_PREFLIGHT" => Some(Self::Preflight),
                "MODE_BEST_EFFORT" => Some(Self::BestEffort),
                "MODE_NORMAL" => Some(Self::Normal),
                "MODE_HIGHEST_ACCURACY" => Some(Self::HighestAccuracy),
                _ => None,
            }
        }
    }
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct DownsampledStorageMeta {
    /// deprecated, only use can_go_to_higher_accuracy_tier
    #[prost(enumeration = "downsampled_storage_meta::SelectedTier", tag = "1")]
    pub tier: i32,
    /// how many rows did the estimator think this query would scan
    /// 0 means the estimator was not run
    /// deprecated, only use can_go_to_higher_accuracy_tier
    #[prost(uint64, tag = "2")]
    pub estimated_num_rows: u64,
    /// if there exists a higher accuracy tier that this query could route to
    /// note that if this query goes to a higher accuracy tier, it could potentially time out
    #[prost(bool, tag = "3")]
    pub can_go_to_higher_accuracy_tier: bool,
}
/// Nested message and enum types in `DownsampledStorageMeta`.
pub mod downsampled_storage_meta {
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
    #[repr(i32)]
    pub enum SelectedTier {
        Unspecified = 0,
        SelectedTier1 = 1,
        SelectedTier8 = 2,
        SelectedTier64 = 3,
        SelectedTier512 = 4,
    }
    impl SelectedTier {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                SelectedTier::Unspecified => "SELECTED_TIER_UNSPECIFIED",
                SelectedTier::SelectedTier1 => "SELECTED_TIER_1",
                SelectedTier::SelectedTier8 => "SELECTED_TIER_8",
                SelectedTier::SelectedTier64 => "SELECTED_TIER_64",
                SelectedTier::SelectedTier512 => "SELECTED_TIER_512",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "SELECTED_TIER_UNSPECIFIED" => Some(Self::Unspecified),
                "SELECTED_TIER_1" => Some(Self::SelectedTier1),
                "SELECTED_TIER_8" => Some(Self::SelectedTier8),
                "SELECTED_TIER_64" => Some(Self::SelectedTier64),
                "SELECTED_TIER_512" => Some(Self::SelectedTier512),
                _ => None,
            }
        }
    }
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct Literal {
    #[prost(oneof = "literal::Value", tags = "1")]
    pub value: ::core::option::Option<literal::Value>,
}
/// Nested message and enum types in `Literal`.
pub mod literal {
    #[derive(Clone, Copy, PartialEq, ::prost::Oneof)]
    pub enum Value {
        #[prost(double, tag = "1")]
        ValDouble(f64),
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RequestMeta {
    /// id of the organization we are querying data for
    #[prost(uint64, tag = "1")]
    pub organization_id: u64,
    /// used for logging and metrics, ex: "snuba_admin", "eap", "replays", etc
    #[prost(string, tag = "2")]
    pub cogs_category: ::prost::alloc::string::String,
    /// identifier for where the request is coming from
    /// ex: "api.profiling.landing-chart", "api.replay.details-page"
    #[prost(string, tag = "3")]
    pub referrer: ::prost::alloc::string::String,
    /// ids of the projects we are querying data for
    #[prost(uint64, repeated, tag = "4")]
    pub project_ids: ::prost::alloc::vec::Vec<u64>,
    /// start timestamp we want to query data for
    #[prost(message, optional, tag = "5")]
    pub start_timestamp: ::core::option::Option<::prost_types::Timestamp>,
    /// end timestamp we want to query data for
    #[prost(message, optional, tag = "6")]
    pub end_timestamp: ::core::option::Option<::prost_types::Timestamp>,
    /// DEPRECATED (not implemented) - use trace_item_type instead
    #[deprecated]
    #[prost(enumeration = "TraceItemName", tag = "7")]
    pub trace_item_name: i32,
    /// the type of the trace item you are querying
    #[prost(enumeration = "TraceItemType", tag = "8")]
    pub trace_item_type: i32,
    /// whether to include debug information in the response
    #[prost(bool, tag = "10")]
    pub debug: bool,
    /// a unique identifier for the request, user doesnt need to set this
    #[prost(string, tag = "11")]
    pub request_id: ::prost::alloc::string::String,
    /// how to query the downsampled storages
    #[prost(message, optional, tag = "12")]
    pub downsampled_storage_config: ::core::option::Option<DownsampledStorageConfig>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ResponseMeta {
    /// id of the request that this response relates to
    #[prost(string, tag = "1")]
    pub request_id: ::prost::alloc::string::String,
    /// Optional field that is included only if debug is true
    #[prost(message, repeated, tag = "2")]
    pub query_info: ::prost::alloc::vec::Vec<QueryInfo>,
    /// metadata of how the query interacted wit the downsampled storages
    #[prost(message, optional, tag = "3")]
    pub downsampled_storage_meta: ::core::option::Option<DownsampledStorageMeta>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PageToken {
    #[prost(oneof = "page_token::Value", tags = "1, 2")]
    pub value: ::core::option::Option<page_token::Value>,
}
/// Nested message and enum types in `PageToken`.
pub mod page_token {
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Value {
        /// standard limit/offset pagination
        #[prost(uint64, tag = "1")]
        Offset(u64),
        /// Instead of using offset (which requires all the scanning and ordering),
        /// the server sends back a filter clause to be added on to the filter conditions
        /// which skips the previous results altogether, avoiding extra scanning and sorting
        #[prost(message, tag = "2")]
        FilterOffset(super::TraceItemFilter),
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct QueryStats {
    #[prost(int64, tag = "1")]
    pub rows_read: i64,
    #[prost(int64, tag = "2")]
    pub columns_read: i64,
    #[prost(int32, tag = "4")]
    pub blocks: i32,
    #[prost(int64, tag = "5")]
    pub progress_bytes: i64,
    #[prost(int32, tag = "8")]
    pub max_threads: i32,
    #[prost(message, optional, tag = "11")]
    pub timing_marks: ::core::option::Option<TimingMarks>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct QueryMetadata {
    #[prost(string, tag = "1")]
    pub sql: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub status: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub clickhouse_table: ::prost::alloc::string::String,
    #[prost(bool, tag = "4")]
    pub r#final: bool,
    #[prost(string, tag = "6")]
    pub query_id: ::prost::alloc::string::String,
    #[prost(bool, tag = "7")]
    pub consistent: bool,
    #[prost(bool, tag = "9")]
    pub cache_hit: bool,
    #[prost(string, tag = "10")]
    pub cluster_name: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TimingMarks {
    #[prost(int64, tag = "1")]
    pub duration_ms: i64,
    #[prost(map = "string, int64", tag = "2")]
    pub marks_ms: ::std::collections::HashMap<::prost::alloc::string::String, i64>,
    #[prost(map = "string, string", tag = "3")]
    pub tags:
        ::std::collections::HashMap<::prost::alloc::string::String, ::prost::alloc::string::String>,
    #[prost(int64, tag = "4")]
    pub timestamp: i64,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct QueryInfo {
    #[prost(message, optional, tag = "1")]
    pub stats: ::core::option::Option<QueryStats>,
    #[prost(message, optional, tag = "2")]
    pub metadata: ::core::option::Option<QueryMetadata>,
    #[prost(string, tag = "3")]
    pub trace_logs: ::prost::alloc::string::String,
}
/// DEPRECATED: use TraceItemType instead
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum TraceItemName {
    Unspecified = 0,
    EapSpans = 1,
    EapErrors = 2,
}
impl TraceItemName {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            TraceItemName::Unspecified => "TRACE_ITEM_NAME_UNSPECIFIED",
            TraceItemName::EapSpans => "TRACE_ITEM_NAME_EAP_SPANS",
            TraceItemName::EapErrors => "TRACE_ITEM_NAME_EAP_ERRORS",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "TRACE_ITEM_NAME_UNSPECIFIED" => Some(Self::Unspecified),
            "TRACE_ITEM_NAME_EAP_SPANS" => Some(Self::EapSpans),
            "TRACE_ITEM_NAME_EAP_ERRORS" => Some(Self::EapErrors),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum TraceItemType {
    Unspecified = 0,
    Span = 1,
    Error = 2,
    Log = 3,
    UptimeCheck = 4,
}
impl TraceItemType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            TraceItemType::Unspecified => "TRACE_ITEM_TYPE_UNSPECIFIED",
            TraceItemType::Span => "TRACE_ITEM_TYPE_SPAN",
            TraceItemType::Error => "TRACE_ITEM_TYPE_ERROR",
            TraceItemType::Log => "TRACE_ITEM_TYPE_LOG",
            TraceItemType::UptimeCheck => "TRACE_ITEM_TYPE_UPTIME_CHECK",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "TRACE_ITEM_TYPE_UNSPECIFIED" => Some(Self::Unspecified),
            "TRACE_ITEM_TYPE_SPAN" => Some(Self::Span),
            "TRACE_ITEM_TYPE_ERROR" => Some(Self::Error),
            "TRACE_ITEM_TYPE_LOG" => Some(Self::Log),
            "TRACE_ITEM_TYPE_UPTIME_CHECK" => Some(Self::UptimeCheck),
            _ => None,
        }
    }
}
/// This is a request to the TimeSeries endpoint,
/// it is used to do a timeseries aggregation of a given attribute
/// across traces.
///
/// ex: avg(span.duration) group by db.system
/// this (conceptually) will return a 2d graph where y-axis is avg(span.duration),
/// x-axis is time, and there is a separate line/function on the graph for each db.system value
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TimeSeriesRequest {
    /// metadata about the request
    /// used to filter time range, organization, project, etc.
    #[prost(message, optional, tag = "1")]
    pub meta: ::core::option::Option<RequestMeta>,
    /// filters out spans (TraceItems) that dont meet the criteria
    /// ex: avg(span.duration) where span.environment = 'production'
    #[prost(message, optional, tag = "2")]
    pub filter: ::core::option::Option<TraceItemFilter>,
    /// deprecated, please use expressions instead
    #[deprecated]
    #[prost(message, repeated, tag = "3")]
    pub aggregations: ::prost::alloc::vec::Vec<AttributeAggregation>,
    /// the actual aggregation to compute ex: avg(span.duration) or avg(span.duration) / sum(span.duration)
    #[prost(message, repeated, tag = "6")]
    pub expressions: ::prost::alloc::vec::Vec<Expression>,
    /// the level of detail in the timeseries graph,
    /// low granularity is very detailed, high is less detail.
    /// ex: if granularity is 1s you will have a data point every 1s,
    ///      if its 1m you have a data point every 1m
    /// tip: for performance, if the query is is over a large time period you should
    ///   have high granularity
    #[prost(uint64, tag = "4")]
    pub granularity_secs: u64,
    /// attribute key to group by
    /// ex: span.environment might give 3 timeseries lines,
    ///      one for prod, one for dev etc
    #[prost(message, repeated, tag = "5")]
    pub group_by: ::prost::alloc::vec::Vec<AttributeKey>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Expression {
    #[prost(string, tag = "3")]
    pub label: ::prost::alloc::string::String,
    #[prost(oneof = "expression::Expression", tags = "1, 2, 4, 5")]
    pub expression: ::core::option::Option<expression::Expression>,
}
/// Nested message and enum types in `Expression`.
pub mod expression {
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct BinaryFormula {
        #[prost(enumeration = "binary_formula::Op", tag = "1")]
        pub op: i32,
        #[prost(message, optional, boxed, tag = "2")]
        pub left: ::core::option::Option<::prost::alloc::boxed::Box<super::Expression>>,
        #[prost(message, optional, boxed, tag = "3")]
        pub right: ::core::option::Option<::prost::alloc::boxed::Box<super::Expression>>,
        /// optional, if the formula evalutates to null this value is returned
        /// formula can evaluate to null if an attribute is missing for example
        #[prost(oneof = "binary_formula::DefaultValue", tags = "4, 5")]
        pub default_value: ::core::option::Option<binary_formula::DefaultValue>,
    }
    /// Nested message and enum types in `BinaryFormula`.
    pub mod binary_formula {
        #[derive(
            Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration,
        )]
        #[repr(i32)]
        pub enum Op {
            Unspecified = 0,
            Divide = 1,
            Multiply = 2,
            Add = 3,
            Subtract = 4,
        }
        impl Op {
            /// String value of the enum field names used in the ProtoBuf definition.
            ///
            /// The values are not transformed in any way and thus are considered stable
            /// (if the ProtoBuf definition does not change) and safe for programmatic use.
            pub fn as_str_name(&self) -> &'static str {
                match self {
                    Op::Unspecified => "OP_UNSPECIFIED",
                    Op::Divide => "OP_DIVIDE",
                    Op::Multiply => "OP_MULTIPLY",
                    Op::Add => "OP_ADD",
                    Op::Subtract => "OP_SUBTRACT",
                }
            }
            /// Creates an enum from field names used in the ProtoBuf definition.
            pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                match value {
                    "OP_UNSPECIFIED" => Some(Self::Unspecified),
                    "OP_DIVIDE" => Some(Self::Divide),
                    "OP_MULTIPLY" => Some(Self::Multiply),
                    "OP_ADD" => Some(Self::Add),
                    "OP_SUBTRACT" => Some(Self::Subtract),
                    _ => None,
                }
            }
        }
        /// optional, if the formula evalutates to null this value is returned
        /// formula can evaluate to null if an attribute is missing for example
        #[derive(Clone, Copy, PartialEq, ::prost::Oneof)]
        pub enum DefaultValue {
            #[prost(double, tag = "4")]
            DefaultValueDouble(f64),
            #[prost(int64, tag = "5")]
            DefaultValueInt64(i64),
        }
    }
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Expression {
        #[prost(message, tag = "1")]
        Aggregation(super::AttributeAggregation),
        #[prost(message, tag = "2")]
        Formula(::prost::alloc::boxed::Box<BinaryFormula>),
        #[prost(message, tag = "4")]
        ConditionalAggregation(super::AttributeConditionalAggregation),
        #[prost(message, tag = "5")]
        Literal(super::Literal),
    }
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct DataPoint {
    #[prost(float, tag = "1")]
    pub data: f32,
    /// false if this datapoint is empty, true otherwise.
    /// optional, if not set assume true.
    /// used for sparse time series
    #[prost(bool, tag = "2")]
    pub data_present: bool,
    /// only set for extrapolated data points, 0 otherwise
    /// the extrapolated avg sampling rate for this data point
    #[prost(float, tag = "3")]
    pub avg_sampling_rate: f32,
    /// deprecated
    #[deprecated]
    #[prost(bool, tag = "4")]
    pub is_reliable: bool,
    /// the reliability of the data value based on math based on confidence intervals and sample size
    #[prost(enumeration = "Reliability", tag = "5")]
    pub reliability: i32,
    /// the sample count for this data point
    #[prost(int64, tag = "6")]
    pub sample_count: i64,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TimeSeries {
    #[prost(string, tag = "1")]
    pub label: ::prost::alloc::string::String,
    /// the names and values of the attribute keys which
    /// were in the group by
    #[prost(map = "string, string", tag = "2")]
    pub group_by_attributes:
        ::std::collections::HashMap<::prost::alloc::string::String, ::prost::alloc::string::String>,
    /// time bucket for each data point in the timeseries
    #[prost(message, repeated, tag = "3")]
    pub buckets: ::prost::alloc::vec::Vec<::prost_types::Timestamp>,
    #[prost(message, repeated, tag = "4")]
    pub data_points: ::prost::alloc::vec::Vec<DataPoint>,
    /// number of events used to calculate this timeseries
    #[prost(uint64, tag = "5")]
    pub num_events: u64,
    /// deprecated
    #[deprecated]
    #[prost(float, tag = "6")]
    pub avg_sampling_rate: f32,
}
/// This is the response from the TimeSeries endpoint,
/// it is the counterpart of TimeSeriesRequest
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TimeSeriesResponse {
    #[prost(message, repeated, tag = "1")]
    pub result_timeseries: ::prost::alloc::vec::Vec<TimeSeries>,
    #[prost(message, optional, tag = "5")]
    pub meta: ::core::option::Option<ResponseMeta>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateSubscriptionRequest {
    #[prost(message, optional, tag = "1")]
    pub time_series_request: ::core::option::Option<TimeSeriesRequest>,
    #[prost(uint32, tag = "2")]
    pub time_window_secs: u32,
    #[prost(uint32, tag = "3")]
    pub resolution_secs: u32,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateSubscriptionResponse {
    #[prost(string, tag = "1")]
    pub subscription_id: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TracePageToken {
    /// This class exists to avoid circular imports with the PageToken class
    /// The next version of the proto will have a PageToken class that can be used
    /// for all endpoints, and this class can be removed.
    #[prost(oneof = "trace_page_token::Value", tags = "1, 2, 3")]
    pub value: ::core::option::Option<trace_page_token::Value>,
}
/// Nested message and enum types in `TracePageToken`.
pub mod trace_page_token {
    /// This class exists to avoid circular imports with the PageToken class
    /// The next version of the proto will have a PageToken class that can be used
    /// for all endpoints, and this class can be removed.
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Value {
        #[prost(uint64, tag = "1")]
        Offset(u64),
        /// Instead of using offset (which requires all the scanning and ordering),
        /// the server sends back a filter clause to be added on to the filter conditions
        /// which skips the previous results altogether, avoiding extra scanning and sorting
        #[prost(message, tag = "2")]
        EventFilter(super::EventFilter),
        #[prost(message, tag = "3")]
        TraceFilter(super::TraceFilter),
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FindTracesRequest {
    #[prost(message, optional, tag = "1")]
    pub meta: ::core::option::Option<RequestMeta>,
    #[prost(message, optional, tag = "2")]
    pub filter: ::core::option::Option<TraceFilter>,
    #[prost(message, optional, tag = "3")]
    pub page_token: ::core::option::Option<TracePageToken>,
    #[prost(enumeration = "TraceOrderBy", tag = "4")]
    pub order_by: i32,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TraceResponse {
    #[prost(string, tag = "1")]
    pub trace_id: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "5")]
    pub start_timestamp: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, optional, tag = "6")]
    pub end_timestamp: ::core::option::Option<::prost_types::Timestamp>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FindTracesResponse {
    #[prost(message, repeated, tag = "1")]
    pub traces: ::prost::alloc::vec::Vec<TraceResponse>,
    #[prost(message, optional, tag = "2")]
    pub page_token: ::core::option::Option<TracePageToken>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct EventFilter {
    #[prost(enumeration = "TraceItemName", tag = "1")]
    pub trace_item_name: i32,
    #[prost(message, optional, tag = "2")]
    pub filter: ::core::option::Option<TraceItemFilter>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AndTraceFilter {
    #[prost(message, repeated, tag = "1")]
    pub filters: ::prost::alloc::vec::Vec<TraceFilter>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct OrTraceFilter {
    #[prost(message, repeated, tag = "1")]
    pub filters: ::prost::alloc::vec::Vec<TraceFilter>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct NotTraceFilter {
    #[prost(message, repeated, tag = "1")]
    pub filters: ::prost::alloc::vec::Vec<TraceFilter>,
}
/// Represents a set of conditions for finding particular events
/// in a trace. Each EventFilter is meant to find one particular
/// type of event. Those can then be combined to find traces that
/// contain different combinations of events.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TraceFilter {
    #[prost(oneof = "trace_filter::Filter", tags = "1, 2, 3, 4")]
    pub filter: ::core::option::Option<trace_filter::Filter>,
}
/// Nested message and enum types in `TraceFilter`.
pub mod trace_filter {
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Filter {
        #[prost(message, tag = "1")]
        AndFilter(super::AndTraceFilter),
        #[prost(message, tag = "2")]
        OrFilter(super::OrTraceFilter),
        #[prost(message, tag = "3")]
        NotFilter(super::NotTraceFilter),
        #[prost(message, tag = "4")]
        EventFilter(super::EventFilter),
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum TraceOrderBy {
    Unspecified = 0,
    EndTime = 1,
    TraceDuration = 2,
}
impl TraceOrderBy {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            TraceOrderBy::Unspecified => "TRACE_ORDER_BY_UNSPECIFIED",
            TraceOrderBy::EndTime => "TRACE_ORDER_BY_END_TIME",
            TraceOrderBy::TraceDuration => "TRACE_ORDER_BY_TRACE_DURATION",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "TRACE_ORDER_BY_UNSPECIFIED" => Some(Self::Unspecified),
            "TRACE_ORDER_BY_END_TIME" => Some(Self::EndTime),
            "TRACE_ORDER_BY_TRACE_DURATION" => Some(Self::TraceDuration),
            _ => None,
        }
    }
}
/// GetTraceRequest lets you query a trace by trace_id, returning all its items.
///
/// Each item will return every attributes by default or you can pass a list of
/// attributes to return for each item type.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetTraceRequest {
    #[prost(message, optional, tag = "1")]
    pub meta: ::core::option::Option<RequestMeta>,
    #[prost(string, tag = "2")]
    pub trace_id: ::prost::alloc::string::String,
    /// A list of items and their attributes to return in the response.
    #[prost(message, repeated, tag = "3")]
    pub items: ::prost::alloc::vec::Vec<get_trace_request::TraceItem>,
}
/// Nested message and enum types in `GetTraceRequest`.
pub mod get_trace_request {
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct TraceItem {
        /// DEPRECATED: use item_type instead
        #[deprecated]
        #[prost(enumeration = "super::TraceItemName", tag = "1")]
        pub r#type: i32,
        /// If attributes is empty, all attributes will be returned for this type.
        #[prost(message, repeated, tag = "2")]
        pub attributes: ::prost::alloc::vec::Vec<super::AttributeKey>,
        #[prost(enumeration = "super::TraceItemType", tag = "3")]
        pub item_type: i32,
    }
}
/// GetTraceResponse returns a trace and all its items.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetTraceResponse {
    #[prost(string, tag = "1")]
    pub trace_id: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "2")]
    pub meta: ::core::option::Option<ResponseMeta>,
    #[prost(message, repeated, tag = "3")]
    pub item_groups: ::prost::alloc::vec::Vec<get_trace_response::ItemGroup>,
}
/// Nested message and enum types in `GetTraceResponse`.
pub mod get_trace_response {
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Item {
        #[prost(string, tag = "1")]
        pub id: ::prost::alloc::string::String,
        #[prost(message, optional, tag = "2")]
        pub timestamp: ::core::option::Option<::prost_types::Timestamp>,
        #[prost(message, repeated, tag = "3")]
        pub attributes: ::prost::alloc::vec::Vec<item::Attribute>,
    }
    /// Nested message and enum types in `Item`.
    pub mod item {
        #[derive(Clone, PartialEq, ::prost::Message)]
        pub struct Attribute {
            #[prost(message, optional, tag = "1")]
            pub key: ::core::option::Option<super::super::AttributeKey>,
            #[prost(message, optional, tag = "2")]
            pub value: ::core::option::Option<super::super::AttributeValue>,
        }
    }
    /// ItemGroup is a list of items of a specific type.
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct ItemGroup {
        /// DEPRECATED: use item_type instead
        #[deprecated]
        #[prost(enumeration = "super::TraceItemName", tag = "1")]
        pub r#type: i32,
        #[prost(message, repeated, tag = "2")]
        pub items: ::prost::alloc::vec::Vec<Item>,
        #[prost(enumeration = "super::TraceItemType", tag = "3")]
        pub item_type: i32,
    }
}
/// TraceAttribute represents the attribute of a trace.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TraceAttribute {
    #[prost(enumeration = "trace_attribute::Key", tag = "1")]
    pub key: i32,
    #[prost(message, optional, tag = "2")]
    pub value: ::core::option::Option<AttributeValue>,
    /// AttributeKey.Type will specify the type of the attribute we return.
    /// It does not need to be sent when requesting an attribute.
    #[prost(enumeration = "attribute_key::Type", tag = "3")]
    pub r#type: i32,
}
/// Nested message and enum types in `TraceAttribute`.
pub mod trace_attribute {
    /// Key lists the available trace attribute keys you can query.
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
    #[repr(i32)]
    pub enum Key {
        Unspecified = 0,
        TraceId = 1,
        /// KEY_START_TIMESTAMP will return the earliest timestamp seen in the trace.
        StartTimestamp = 2,
        /// KEY_ROOT_SPAN_NAME will return the name of the root (segment) span of
        /// the trace.
        RootSpanName = 3,
        /// KEY_TOTAL_ITEM_COUNT will return the count of all the items in a trace,
        /// regardless of the conditions applied.
        TotalItemCount = 4,
        /// KEY_FILTERED_ITEM_COUNT will return the count of items where the filters
        /// apply.
        /// For example, in a trace with 5 items (1 http.server span, 4 db spans),
        /// if we query for traces with span.op == "db", this will return 4.
        FilteredItemCount = 5,
        /// KEY_ROOT_SPAN_DURATION_MS will return the duration of the root span in
        /// milliseconds.
        RootSpanDurationMs = 6,
        /// KEY_ROOT_SPAN_PROJECT_ID returns the project ID associated with the root
        /// span.
        RootSpanProjectId = 7,
        /// KEY_EARLIEST_SPAN_NAME returns the name of the earliest span of a trace,
        /// regardless if it's a root span or not
        EarliestSpanName = 8,
        /// KEY_EARLIEST_FRONTEND_SPAN returns the name of the earliest span emitted
        /// by the frontend (for example, span op being `pageload` or `navigation`).
        EarliestFrontendSpan = 9,
        /// KEY_END_TIMESTAMP will return the latest timestamp seen in the trace.
        EndTimestamp = 10,
        /// KEY_EARLIEST_SPAN_PROJECT_ID returns the project ID associated with the earliest span.
        EarliestSpanProjectId = 11,
        /// KEY_EARLIEST_SPAN_DURATION_MS will return the duration of the earliest span in milliseconds.
        EarliestSpanDurationMs = 12,
        /// KEY_EARLIEST_FRONTEND_SPAN_PROJECT_ID returns the project ID associated with the earliest frontend span.
        EarliestFrontendSpanProjectId = 13,
        /// KEY_EARLIEST_FRONTEND_SPAN_DURATION_MS will return the duration of the earliest frontend span in milliseconds.
        EarliestFrontendSpanDurationMs = 14,
    }
    impl Key {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Key::Unspecified => "KEY_UNSPECIFIED",
                Key::TraceId => "KEY_TRACE_ID",
                Key::StartTimestamp => "KEY_START_TIMESTAMP",
                Key::RootSpanName => "KEY_ROOT_SPAN_NAME",
                Key::TotalItemCount => "KEY_TOTAL_ITEM_COUNT",
                Key::FilteredItemCount => "KEY_FILTERED_ITEM_COUNT",
                Key::RootSpanDurationMs => "KEY_ROOT_SPAN_DURATION_MS",
                Key::RootSpanProjectId => "KEY_ROOT_SPAN_PROJECT_ID",
                Key::EarliestSpanName => "KEY_EARLIEST_SPAN_NAME",
                Key::EarliestFrontendSpan => "KEY_EARLIEST_FRONTEND_SPAN",
                Key::EndTimestamp => "KEY_END_TIMESTAMP",
                Key::EarliestSpanProjectId => "KEY_EARLIEST_SPAN_PROJECT_ID",
                Key::EarliestSpanDurationMs => "KEY_EARLIEST_SPAN_DURATION_MS",
                Key::EarliestFrontendSpanProjectId => "KEY_EARLIEST_FRONTEND_SPAN_PROJECT_ID",
                Key::EarliestFrontendSpanDurationMs => "KEY_EARLIEST_FRONTEND_SPAN_DURATION_MS",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "KEY_UNSPECIFIED" => Some(Self::Unspecified),
                "KEY_TRACE_ID" => Some(Self::TraceId),
                "KEY_START_TIMESTAMP" => Some(Self::StartTimestamp),
                "KEY_ROOT_SPAN_NAME" => Some(Self::RootSpanName),
                "KEY_TOTAL_ITEM_COUNT" => Some(Self::TotalItemCount),
                "KEY_FILTERED_ITEM_COUNT" => Some(Self::FilteredItemCount),
                "KEY_ROOT_SPAN_DURATION_MS" => Some(Self::RootSpanDurationMs),
                "KEY_ROOT_SPAN_PROJECT_ID" => Some(Self::RootSpanProjectId),
                "KEY_EARLIEST_SPAN_NAME" => Some(Self::EarliestSpanName),
                "KEY_EARLIEST_FRONTEND_SPAN" => Some(Self::EarliestFrontendSpan),
                "KEY_END_TIMESTAMP" => Some(Self::EndTimestamp),
                "KEY_EARLIEST_SPAN_PROJECT_ID" => Some(Self::EarliestSpanProjectId),
                "KEY_EARLIEST_SPAN_DURATION_MS" => Some(Self::EarliestSpanDurationMs),
                "KEY_EARLIEST_FRONTEND_SPAN_PROJECT_ID" => {
                    Some(Self::EarliestFrontendSpanProjectId)
                }
                "KEY_EARLIEST_FRONTEND_SPAN_DURATION_MS" => {
                    Some(Self::EarliestFrontendSpanDurationMs)
                }
                _ => None,
            }
        }
    }
}
/// GetTracesRequest lets you query traces with various attributes.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetTracesRequest {
    #[prost(message, optional, tag = "1")]
    pub meta: ::core::option::Option<RequestMeta>,
    #[prost(message, optional, tag = "2")]
    pub page_token: ::core::option::Option<PageToken>,
    #[prost(uint32, tag = "3")]
    pub limit: u32,
    /// List of filters on items of the trace we'll use when querying.
    #[prost(message, repeated, tag = "4")]
    pub filters: ::prost::alloc::vec::Vec<get_traces_request::TraceFilter>,
    /// List of attributes we'd like to order by.
    #[prost(message, repeated, tag = "5")]
    pub order_by: ::prost::alloc::vec::Vec<get_traces_request::OrderBy>,
    /// List of attributes we want to query.
    #[prost(message, repeated, tag = "6")]
    pub attributes: ::prost::alloc::vec::Vec<TraceAttribute>,
}
/// Nested message and enum types in `GetTracesRequest`.
pub mod get_traces_request {
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct OrderBy {
        #[prost(enumeration = "super::trace_attribute::Key", tag = "1")]
        pub key: i32,
        #[prost(bool, tag = "2")]
        pub descending: bool,
    }
    /// TraceFilter specifies conditions to apply on the items contained in a trace.
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct TraceFilter {
        /// DEPRECATED: use item_type
        #[deprecated]
        #[prost(enumeration = "super::TraceItemName", tag = "1")]
        pub item_name: i32,
        #[prost(message, optional, tag = "2")]
        pub filter: ::core::option::Option<super::TraceItemFilter>,
        /// the item type we will apply the filter condition on.
        #[prost(enumeration = "super::TraceItemType", tag = "3")]
        pub item_type: i32,
    }
}
/// GetTracesResponse contains a list of traces returned by the request.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetTracesResponse {
    #[prost(message, optional, tag = "1")]
    pub page_token: ::core::option::Option<PageToken>,
    #[prost(message, optional, tag = "2")]
    pub meta: ::core::option::Option<ResponseMeta>,
    /// List of traces matching conditions.
    #[prost(message, repeated, tag = "3")]
    pub traces: ::prost::alloc::vec::Vec<get_traces_response::Trace>,
}
/// Nested message and enum types in `GetTracesResponse`.
pub mod get_traces_response {
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Trace {
        /// List of attributes queried.
        #[prost(message, repeated, tag = "1")]
        pub attributes: ::prost::alloc::vec::Vec<super::TraceAttribute>,
    }
}
/// TraceItemAttributeNamesRequest is a request to the TraceItemAttributeNames endpoint,
/// it returns the names of all queryable "TraceItemAttributes" that exist in the given projects,
/// date range, and other filters.
///
/// TraceItem are things like: span, error, log, replay
/// TraceItemAttributes could be things like: sentry.duration,user_id cart_total, etc.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TraceItemAttributeNamesRequest {
    /// metadata about the request
    /// this is where you specify organization, project, time range etc.
    #[prost(message, optional, tag = "1")]
    pub meta: ::core::option::Option<RequestMeta>,
    /// maximum number of attributes to return
    #[prost(uint32, tag = "2")]
    pub limit: u32,
    /// offset is deprecated, please use `page_token` instead
    #[deprecated]
    #[prost(uint32, tag = "3")]
    pub offset: u32,
    /// The type of the attributes to return, must be specified,
    /// only TYPE_STRING and TYPE_FLOAT are supported, anything else will return empty response
    #[prost(enumeration = "attribute_key::Type", tag = "5")]
    pub r#type: i32,
    /// optionalfilter to only return attribute names that match the given substring
    #[prost(string, tag = "6")]
    pub value_substring_match: ::prost::alloc::string::String,
    /// optional, used for pagination, the next page token will be returned in the response
    #[prost(message, optional, tag = "7")]
    pub page_token: ::core::option::Option<PageToken>,
    /// A filter to only get relevant attribute keys
    /// including this makes sure that only attribute keys are returned
    /// which *intersect* with the ones specified in the filter.
    /// This is a BEST-EFFORT operation. If no co-occurring keys are found within
    /// 1 second, the endpoint returns without taking the intersecing attributes into account
    #[prost(message, optional, tag = "8")]
    pub intersecting_attributes_filter: ::core::option::Option<TraceItemFilter>,
}
/// TraceItemAttributeNamesResponse is the response returned by the TraceItemAttributeNames endpoint.
/// It is the counterpart to TraceItemAttributeNamesRequest.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TraceItemAttributeNamesResponse {
    /// all attributes that matched the filters in the request
    #[prost(message, repeated, tag = "1")]
    pub attributes: ::prost::alloc::vec::Vec<trace_item_attribute_names_response::Attribute>,
    /// page token for the next page of results
    #[prost(message, optional, tag = "2")]
    pub page_token: ::core::option::Option<PageToken>,
    /// metadata about the response
    #[prost(message, optional, tag = "3")]
    pub meta: ::core::option::Option<ResponseMeta>,
}
/// Nested message and enum types in `TraceItemAttributeNamesResponse`.
pub mod trace_item_attribute_names_response {
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Attribute {
        #[prost(string, tag = "1")]
        pub name: ::prost::alloc::string::String,
        #[prost(enumeration = "super::attribute_key::Type", tag = "2")]
        pub r#type: i32,
    }
}
/// TraceItemAttributeValuesRequest is a request to the TraceItemAttributeValues endpoint,
/// it returns the set of all possible values for the given attribute key, across the given
/// organization, project_id, timerange etc (specified in meta).
///
/// This endpoint only supports string values, it does not make sense
/// to get all the possible values of a numerical attribute
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TraceItemAttributeValuesRequest {
    /// metadata about the request
    /// this is where you specify organization, project, time range etc.
    #[prost(message, optional, tag = "1")]
    pub meta: ::core::option::Option<RequestMeta>,
    /// attribute you want the values of
    #[prost(message, optional, tag = "2")]
    pub key: ::core::option::Option<AttributeKey>,
    /// deprecated, please use the `key` field instead
    #[deprecated]
    #[prost(string, tag = "3")]
    pub name: ::prost::alloc::string::String,
    /// a substring of the value being searched for,
    /// only values matching this substring will be returned.
    /// only strict substring supported, no regex
    #[prost(string, tag = "4")]
    pub value_substring_match: ::prost::alloc::string::String,
    /// max number of values to return
    #[prost(uint32, tag = "5")]
    pub limit: u32,
    /// optional, used for pagination, the next page token will be returned in the response
    #[prost(message, optional, tag = "6")]
    pub page_token: ::core::option::Option<PageToken>,
}
/// TraceItemAttributeValuesResponse is a response from the TraceItemAttributeValues endpoint
/// it is the counterpart to TraceItemAttributesRequest
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TraceItemAttributeValuesResponse {
    /// all the values that matched the criteria specified in the request
    #[prost(string, repeated, tag = "1")]
    pub values: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// page token for the next page of results
    #[prost(message, optional, tag = "6")]
    pub page_token: ::core::option::Option<PageToken>,
    /// metadata about the response
    #[prost(message, optional, tag = "7")]
    pub meta: ::core::option::Option<ResponseMeta>,
}
/// This is a request to the TraceItemDetails endpoint,
/// it is used to query for TraceItems (ex. spans or logs)
/// it returns all of the information for a specific trace item.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TraceItemDetailsRequest {
    #[prost(message, optional, tag = "1")]
    pub meta: ::core::option::Option<RequestMeta>,
    /// required: the ID (hex string) of the item you are looking for
    #[prost(string, tag = "2")]
    pub item_id: ::prost::alloc::string::String,
    /// required: the trace ID of the item.
    #[prost(string, tag = "4")]
    pub trace_id: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "3")]
    pub filter: ::core::option::Option<TraceItemFilter>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TraceItemDetailsAttribute {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "2")]
    pub value: ::core::option::Option<AttributeValue>,
}
/// this is a response from the TraceItemDetails endpoint
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TraceItemDetailsResponse {
    #[prost(string, tag = "1")]
    pub item_id: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "2")]
    pub timestamp: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, repeated, tag = "3")]
    pub attributes: ::prost::alloc::vec::Vec<TraceItemDetailsAttribute>,
    #[prost(message, optional, tag = "4")]
    pub meta: ::core::option::Option<ResponseMeta>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct AttributeDistributionsRequest {
    /// max_buckets and limit wouldn't apply to other stats types (like totals)
    #[prost(uint32, tag = "1")]
    pub max_buckets: u32,
    #[prost(uint32, tag = "2")]
    pub max_attributes: u32,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct StatsType {
    #[prost(oneof = "stats_type::Type", tags = "1")]
    pub r#type: ::core::option::Option<stats_type::Type>,
}
/// Nested message and enum types in `StatsType`.
pub mod stats_type {
    #[derive(Clone, Copy, PartialEq, ::prost::Oneof)]
    pub enum Type {
        #[prost(message, tag = "1")]
        AttributeDistributions(super::AttributeDistributionsRequest),
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TraceItemStatsRequest {
    #[prost(message, optional, tag = "1")]
    pub meta: ::core::option::Option<RequestMeta>,
    /// same filter applies to all stats types requested
    #[prost(message, optional, tag = "2")]
    pub filter: ::core::option::Option<TraceItemFilter>,
    #[prost(message, repeated, tag = "3")]
    pub stats_types: ::prost::alloc::vec::Vec<StatsType>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AttributeDistribution {
    #[prost(string, tag = "1")]
    pub attribute_name: ::prost::alloc::string::String,
    #[prost(message, repeated, tag = "2")]
    pub buckets: ::prost::alloc::vec::Vec<attribute_distribution::Bucket>,
}
/// Nested message and enum types in `AttributeDistribution`.
pub mod attribute_distribution {
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Bucket {
        #[prost(string, tag = "1")]
        pub label: ::prost::alloc::string::String,
        #[prost(float, tag = "2")]
        pub value: f32,
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AttributeDistributions {
    #[prost(message, repeated, tag = "1")]
    pub attributes: ::prost::alloc::vec::Vec<AttributeDistribution>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TraceItemStatsResult {
    #[prost(oneof = "trace_item_stats_result::Result", tags = "1")]
    pub result: ::core::option::Option<trace_item_stats_result::Result>,
}
/// Nested message and enum types in `TraceItemStatsResult`.
pub mod trace_item_stats_result {
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Result {
        #[prost(message, tag = "1")]
        AttributeDistributions(super::AttributeDistributions),
    }
}
/// this is a response from the TraceItemStats endpoint
/// it is the counterpart to TraceItemStatsRequest
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TraceItemStatsResponse {
    #[prost(message, repeated, tag = "1")]
    pub results: ::prost::alloc::vec::Vec<TraceItemStatsResult>,
    #[prost(message, optional, tag = "2")]
    pub page_token: ::core::option::Option<PageToken>,
    #[prost(message, optional, tag = "3")]
    pub meta: ::core::option::Option<ResponseMeta>,
}
/// This is a request to the TraceItemTable endpoint,
/// it is used to query for TraceItems (ex. spans)
/// it returns tabular data where each row is a TraceItem,
/// and the columns are the attributes of the TraceItem
/// it can also be used for aggregations
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TraceItemTableRequest {
    #[prost(message, optional, tag = "1")]
    pub meta: ::core::option::Option<RequestMeta>,
    /// the columns or aggregations you want to get
    #[prost(message, repeated, tag = "2")]
    pub columns: ::prost::alloc::vec::Vec<Column>,
    /// filter out trace items you dont want
    #[prost(message, optional, tag = "3")]
    pub filter: ::core::option::Option<TraceItemFilter>,
    #[prost(message, repeated, tag = "4")]
    pub order_by: ::prost::alloc::vec::Vec<trace_item_table_request::OrderBy>,
    #[prost(message, repeated, tag = "5")]
    pub group_by: ::prost::alloc::vec::Vec<AttributeKey>,
    #[prost(uint32, tag = "6")]
    pub limit: u32,
    /// optional, used for pagination, the next page token will be returned in the response
    #[prost(message, optional, tag = "7")]
    pub page_token: ::core::option::Option<PageToken>,
    #[prost(message, repeated, tag = "8")]
    pub virtual_column_contexts: ::prost::alloc::vec::Vec<VirtualColumnContext>,
    /// optional, filter out results of aggregates, same as SQL HAVING
    #[prost(message, optional, tag = "9")]
    pub aggregation_filter: ::core::option::Option<AggregationFilter>,
}
/// Nested message and enum types in `TraceItemTableRequest`.
pub mod trace_item_table_request {
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct OrderBy {
        #[prost(message, optional, tag = "1")]
        pub column: ::core::option::Option<super::Column>,
        #[prost(bool, tag = "2")]
        pub descending: bool,
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AggregationAndFilter {
    #[prost(message, repeated, tag = "1")]
    pub filters: ::prost::alloc::vec::Vec<AggregationFilter>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AggregationOrFilter {
    #[prost(message, repeated, tag = "1")]
    pub filters: ::prost::alloc::vec::Vec<AggregationFilter>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AggregationComparisonFilter {
    /// deprecated as columns should always be aggregated in a post aggregation filter
    #[deprecated]
    #[prost(message, optional, tag = "1")]
    pub column: ::core::option::Option<Column>,
    #[prost(enumeration = "aggregation_comparison_filter::Op", tag = "2")]
    pub op: i32,
    /// since only aggregated columns are supported, the value should be numeric
    #[deprecated]
    #[prost(message, optional, tag = "3")]
    pub value: ::core::option::Option<AttributeValue>,
    #[prost(double, tag = "5")]
    pub val: f64,
    #[prost(message, optional, tag = "4")]
    pub aggregation: ::core::option::Option<AttributeAggregation>,
    #[prost(message, optional, tag = "6")]
    pub conditional_aggregation: ::core::option::Option<AttributeConditionalAggregation>,
}
/// Nested message and enum types in `AggregationComparisonFilter`.
pub mod aggregation_comparison_filter {
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
    #[repr(i32)]
    pub enum Op {
        Unspecified = 0,
        LessThan = 1,
        GreaterThan = 2,
        LessThanOrEquals = 3,
        GreaterThanOrEquals = 4,
        Equals = 5,
        NotEquals = 6,
    }
    impl Op {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Op::Unspecified => "OP_UNSPECIFIED",
                Op::LessThan => "OP_LESS_THAN",
                Op::GreaterThan => "OP_GREATER_THAN",
                Op::LessThanOrEquals => "OP_LESS_THAN_OR_EQUALS",
                Op::GreaterThanOrEquals => "OP_GREATER_THAN_OR_EQUALS",
                Op::Equals => "OP_EQUALS",
                Op::NotEquals => "OP_NOT_EQUALS",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "OP_UNSPECIFIED" => Some(Self::Unspecified),
                "OP_LESS_THAN" => Some(Self::LessThan),
                "OP_GREATER_THAN" => Some(Self::GreaterThan),
                "OP_LESS_THAN_OR_EQUALS" => Some(Self::LessThanOrEquals),
                "OP_GREATER_THAN_OR_EQUALS" => Some(Self::GreaterThanOrEquals),
                "OP_EQUALS" => Some(Self::Equals),
                "OP_NOT_EQUALS" => Some(Self::NotEquals),
                _ => None,
            }
        }
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AggregationFilter {
    #[prost(oneof = "aggregation_filter::Value", tags = "1, 2, 3")]
    pub value: ::core::option::Option<aggregation_filter::Value>,
}
/// Nested message and enum types in `AggregationFilter`.
pub mod aggregation_filter {
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Value {
        #[prost(message, tag = "1")]
        AndFilter(super::AggregationAndFilter),
        #[prost(message, tag = "2")]
        OrFilter(super::AggregationOrFilter),
        #[prost(message, tag = "3")]
        ComparisonFilter(super::AggregationComparisonFilter),
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Column {
    #[prost(string, tag = "3")]
    pub label: ::prost::alloc::string::String,
    #[prost(oneof = "column::Column", tags = "1, 2, 5, 4, 6")]
    pub column: ::core::option::Option<column::Column>,
}
/// Nested message and enum types in `Column`.
pub mod column {
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct BinaryFormula {
        #[prost(enumeration = "binary_formula::Op", tag = "1")]
        pub op: i32,
        #[prost(message, optional, boxed, tag = "2")]
        pub left: ::core::option::Option<::prost::alloc::boxed::Box<super::Column>>,
        #[prost(message, optional, boxed, tag = "3")]
        pub right: ::core::option::Option<::prost::alloc::boxed::Box<super::Column>>,
        /// optional, if the formula evalutates to null this value is returned
        /// formula can evaluate to null if an attribute is missing for example
        #[prost(oneof = "binary_formula::DefaultValue", tags = "4, 5")]
        pub default_value: ::core::option::Option<binary_formula::DefaultValue>,
    }
    /// Nested message and enum types in `BinaryFormula`.
    pub mod binary_formula {
        #[derive(
            Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration,
        )]
        #[repr(i32)]
        pub enum Op {
            Unspecified = 0,
            Divide = 1,
            Multiply = 2,
            Add = 3,
            Subtract = 4,
        }
        impl Op {
            /// String value of the enum field names used in the ProtoBuf definition.
            ///
            /// The values are not transformed in any way and thus are considered stable
            /// (if the ProtoBuf definition does not change) and safe for programmatic use.
            pub fn as_str_name(&self) -> &'static str {
                match self {
                    Op::Unspecified => "OP_UNSPECIFIED",
                    Op::Divide => "OP_DIVIDE",
                    Op::Multiply => "OP_MULTIPLY",
                    Op::Add => "OP_ADD",
                    Op::Subtract => "OP_SUBTRACT",
                }
            }
            /// Creates an enum from field names used in the ProtoBuf definition.
            pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                match value {
                    "OP_UNSPECIFIED" => Some(Self::Unspecified),
                    "OP_DIVIDE" => Some(Self::Divide),
                    "OP_MULTIPLY" => Some(Self::Multiply),
                    "OP_ADD" => Some(Self::Add),
                    "OP_SUBTRACT" => Some(Self::Subtract),
                    _ => None,
                }
            }
        }
        /// optional, if the formula evalutates to null this value is returned
        /// formula can evaluate to null if an attribute is missing for example
        #[derive(Clone, Copy, PartialEq, ::prost::Oneof)]
        pub enum DefaultValue {
            #[prost(double, tag = "4")]
            DefaultValueDouble(f64),
            #[prost(int64, tag = "5")]
            DefaultValueInt64(i64),
        }
    }
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Column {
        #[prost(message, tag = "1")]
        Key(super::AttributeKey),
        #[prost(message, tag = "2")]
        Aggregation(super::AttributeAggregation),
        #[prost(message, tag = "5")]
        ConditionalAggregation(super::AttributeConditionalAggregation),
        #[prost(message, tag = "4")]
        Formula(::prost::alloc::boxed::Box<BinaryFormula>),
        #[prost(message, tag = "6")]
        Literal(super::Literal),
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TraceItemColumnValues {
    #[prost(string, tag = "1")]
    pub attribute_name: ::prost::alloc::string::String,
    #[prost(message, repeated, tag = "2")]
    pub results: ::prost::alloc::vec::Vec<AttributeValue>,
    /// reliability of the values based on confidence interval and sample size math
    #[prost(enumeration = "Reliability", repeated, tag = "3")]
    pub reliabilities: ::prost::alloc::vec::Vec<i32>,
}
/// this is a response from the TraceItemTable endpoint
/// it is the counterpart to TraceItemTableRequest
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TraceItemTableResponse {
    /// the rows
    #[prost(message, repeated, tag = "1")]
    pub column_values: ::prost::alloc::vec::Vec<TraceItemColumnValues>,
    /// page token for the next page of results
    #[prost(message, optional, tag = "2")]
    pub page_token: ::core::option::Option<PageToken>,
    #[prost(message, optional, tag = "3")]
    pub meta: ::core::option::Option<ResponseMeta>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateTraceItemTableSubscriptionRequest {
    #[prost(message, optional, tag = "1")]
    pub table_request: ::core::option::Option<TraceItemTableRequest>,
    #[prost(uint64, tag = "2")]
    pub project_id: u64,
    #[prost(uint32, tag = "3")]
    pub time_window: u32,
    #[prost(uint32, tag = "4")]
    pub resolution: u32,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateTraceItemTableSubscriptionResponse {
    #[prost(string, tag = "1")]
    pub subscription_id: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Error {
    /// The HTTP status code corresponding to this error
    #[prost(int32, tag = "1")]
    pub code: i32,
    /// The developer-facing message
    #[prost(string, tag = "2")]
    pub message: ::prost::alloc::string::String,
    /// Additional error information
    #[prost(message, repeated, tag = "3")]
    pub details: ::prost::alloc::vec::Vec<::prost_types::Any>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AnyValue {
    #[prost(oneof = "any_value::Value", tags = "1, 2, 3, 4, 5, 6, 7")]
    pub value: ::core::option::Option<any_value::Value>,
}
/// Nested message and enum types in `AnyValue`.
pub mod any_value {
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Value {
        #[prost(string, tag = "1")]
        StringValue(::prost::alloc::string::String),
        #[prost(bool, tag = "2")]
        BoolValue(bool),
        #[prost(int64, tag = "3")]
        IntValue(i64),
        #[prost(double, tag = "4")]
        DoubleValue(f64),
        #[prost(message, tag = "5")]
        ArrayValue(super::ArrayValue),
        #[prost(message, tag = "6")]
        KvlistValue(super::KeyValueList),
        #[prost(bytes, tag = "7")]
        BytesValue(::prost::alloc::vec::Vec<u8>),
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ArrayValue {
    #[prost(message, repeated, tag = "1")]
    pub values: ::prost::alloc::vec::Vec<AnyValue>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct KeyValueList {
    #[prost(message, repeated, tag = "1")]
    pub values: ::prost::alloc::vec::Vec<KeyValue>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct KeyValue {
    #[prost(string, tag = "1")]
    pub key: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "2")]
    pub value: ::core::option::Option<AnyValue>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TraceItem {
    #[prost(uint64, tag = "1")]
    pub organization_id: u64,
    #[prost(uint64, tag = "2")]
    pub project_id: u64,
    #[prost(string, tag = "3")]
    pub trace_id: ::prost::alloc::string::String,
    /// item_id as bytes, little endian
    #[prost(bytes = "vec", tag = "4")]
    pub item_id: ::prost::alloc::vec::Vec<u8>,
    #[prost(enumeration = "TraceItemType", tag = "5")]
    pub item_type: i32,
    #[prost(message, optional, tag = "6")]
    pub timestamp: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(map = "string, message", tag = "7")]
    pub attributes: ::std::collections::HashMap<::prost::alloc::string::String, AnyValue>,
    #[prost(double, tag = "8")]
    pub client_sample_rate: f64,
    #[prost(double, tag = "9")]
    pub server_sample_rate: f64,
    /// Internal fields
    #[prost(uint32, tag = "100")]
    pub retention_days: u32,
    #[prost(message, optional, tag = "101")]
    pub received: ::core::option::Option<::prost_types::Timestamp>,
}
