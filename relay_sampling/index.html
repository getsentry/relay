<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="Sampling logic for performing sampling decisions of incoming events."><title>relay_sampling - Rust</title><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/SourceSerif4-Regular-46f98efaafac5295.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/FiraSans-Regular-018c141bf0843ffd.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/FiraSans-Medium-8f9a781e4970d388.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/SourceCodePro-Regular-562dcc5011b6de7d.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/SourceSerif4-Bold-a2c9cd1067f8b328.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/SourceCodePro-Semibold-d899c5a5c4aeb14a.ttf.woff2"><link rel="stylesheet" href="../static.files/normalize-76eba96aa4d2e634.css"><link rel="stylesheet" href="../static.files/rustdoc-9bb858ba049f1f21.css" id="mainThemeStyle"><meta name="rustdoc-vars" data-root-path="../" data-static-root-path="../static.files/" data-current-crate="relay_sampling" data-themes="" data-resource-suffix="" data-rustdoc-version="1.72.0 (5680fa18f 2023-08-23)" data-channel="1.72.0" data-search-js="search-f6292fe389d70017.js" data-settings-js="settings-de11bff964e9d4e5.js" data-settings-css="settings-8c76f75bfb6bd192.css" data-theme-light-css="light-0f8c037637f9eb3e.css" data-theme-dark-css="dark-1097f8e92a01e3cf.css" data-theme-ayu-css="ayu-614652228113ac93.css" ><script src="../static.files/storage-59fd9b8ccb335783.js"></script><script defer src="../crates.js"></script><script defer src="../static.files/main-0795b7d26be81095.js"></script><noscript><link rel="stylesheet" media="(prefers-color-scheme:light)" href="../static.files/light-0f8c037637f9eb3e.css"><link rel="stylesheet" media="(prefers-color-scheme:dark)" href="../static.files/dark-1097f8e92a01e3cf.css"><link rel="stylesheet" href="../static.files/noscript-13285aec31fa243e.css"></noscript><link rel="icon" href="https://raw.githubusercontent.com/getsentry/relay/master/artwork/relay-icon.png"></head><body class="rustdoc mod crate"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle">&#9776;</button><a class="logo-container" href="../relay_sampling/index.html"><img src="https://raw.githubusercontent.com/getsentry/relay/master/artwork/relay-icon.png" alt="logo"></a><h2></h2></nav><nav class="sidebar"><a class="logo-container" href="../relay_sampling/index.html"><img src="https://raw.githubusercontent.com/getsentry/relay/master/artwork/relay-icon.png" alt="logo"></a><h2 class="location"><a href="#">Crate relay_sampling</a></h2><div class="sidebar-elems"><ul class="block"><li class="version">Version 23.8.0</li><li><a id="all-types" href="all.html">All Items</a></li></ul><section><ul class="block"><li><a href="#structs">Structs</a></li><li><a href="#enums">Enums</a></li><li><a href="#traits">Traits</a></li><li><a href="#functions">Functions</a></li></ul></section></div></nav><main><div class="width-limiter"><nav class="sub"><form class="search-form"><span></span><input class="search-input" name="search" aria-label="Run search in the documentation" autocomplete="off" spellcheck="false" placeholder="Click or press ‘S’ to search, ‘?’ for more options…" type="search"><div id="help-button" title="help" tabindex="-1"><a href="../help.html">?</a></div><div id="settings-menu" tabindex="-1"><a href="../settings.html" title="settings"><img width="22" height="22" alt="Change settings" src="../static.files/wheel-7b819b6101059cd0.svg"></a></div></form></nav><section id="main-content" class="content"><div class="main-heading"><h1>Crate <a class="mod" href="#">relay_sampling</a><button id="copy-path" title="Copy item path to clipboard"><img src="../static.files/clipboard-7571035ce49a181d.svg" width="19" height="18" alt="Copy item path"></button></h1><span class="out-of-band"><a class="srclink" href="../src/relay_sampling/lib.rs.html#1-4002">source</a> · <button id="toggle-all-docs" title="collapse all docs">[<span>&#x2212;</span>]</button></span></div><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>Sampling logic for performing sampling decisions of incoming events.</p>
<p>In order to allow Sentry to offer performance at scale, Relay extracts key <code>metrics</code> from
all transactions, but only forwards a random sample of raw transaction payloads to the upstream.
What exact percentage is sampled is determined by <code>dynamic sampling rules</code>, and depends on
the project, the environment, the transaction name, etc.</p>
<p>In order to determine the sample rate, Relay uses a <a href="struct.SamplingConfig.html" title="struct relay_sampling::SamplingConfig"><code>SamplingConfig</code></a> which contains a set of
<a href="struct.SamplingRule.html" title="struct relay_sampling::SamplingRule"><code>SamplingRule</code></a>s that are matched against the incoming [<code>Event</code>] or <a href="struct.DynamicSamplingContext.html" title="struct relay_sampling::DynamicSamplingContext"><code>DynamicSamplingContext</code></a>.</p>
<h2 id="trace-and-transaction-sampling"><a href="#trace-and-transaction-sampling">Trace and Transaction Sampling</a></h2>
<p>Relay samples both transactions looking at [<code>Event</code>] and traces looking at <a href="struct.DynamicSamplingContext.html" title="struct relay_sampling::DynamicSamplingContext"><code>DynamicSamplingContext</code></a>:</p>
<ul>
<li><strong>Trace sampling</strong>: ensures that either all transactions of a trace are sampled or none.</li>
<li><strong>Transaction sampling</strong>: does not guarantee complete traces and instead applies to individual transactions.</li>
</ul>
<h2 id="components"><a href="#components">Components</a></h2>
<p>The sampling system implemented in Relay is composed of the following components:</p>
<ul>
<li><a href="struct.DynamicSamplingContext.html" title="struct relay_sampling::DynamicSamplingContext"><code>DynamicSamplingContext</code></a>: a struct that contains the trace information.</li>
<li><a href="trait.FieldValueProvider.html" title="trait relay_sampling::FieldValueProvider"><code>FieldValueProvider</code></a>: an abstraction implemented by [<code>Event</code>] and <a href="struct.DynamicSamplingContext.html" title="struct relay_sampling::DynamicSamplingContext"><code>DynamicSamplingContext</code></a> to
expose fields that are read during matching.</li>
<li><a href="struct.SamplingRule.html" title="struct relay_sampling::SamplingRule"><code>SamplingRule</code></a>: a rule that is matched against [<code>Event</code>] or <a href="struct.DynamicSamplingContext.html" title="struct relay_sampling::DynamicSamplingContext"><code>DynamicSamplingContext</code></a> that
can contain a <a href="enum.RuleCondition.html" title="enum relay_sampling::RuleCondition"><code>RuleCondition</code></a> for expressing predicates on the incoming payload.</li>
<li><a href="struct.SamplingMatch.html" title="struct relay_sampling::SamplingMatch"><code>SamplingMatch</code></a>: the result of the matching of one or more <a href="struct.SamplingRule.html" title="struct relay_sampling::SamplingRule"><code>SamplingRule</code></a>.</li>
</ul>
<h2 id="how-it-works"><a href="#how-it-works">How It Works</a></h2>
<ul>
<li>The incoming [<code>Event</code>] and optionally <a href="struct.DynamicSamplingContext.html" title="struct relay_sampling::DynamicSamplingContext"><code>DynamicSamplingContext</code></a> are received by Relay.</li>
<li>Relay fetches the <a href="struct.SamplingConfig.html" title="struct relay_sampling::SamplingConfig"><code>SamplingConfig</code></a> of the project to which the [<code>Event</code>] belongs and (if exists) the
<a href="struct.SamplingConfig.html" title="struct relay_sampling::SamplingConfig"><code>SamplingConfig</code></a> of the root project of the trace.</li>
<li>The <a href="struct.SamplingConfig.html" title="struct relay_sampling::SamplingConfig"><code>SamplingConfig</code></a>s are merged together and the matching algorithm in
<a href="struct.SamplingMatch.html#method.match_against_rules" title="associated function relay_sampling::SamplingMatch::match_against_rules"><code>SamplingMatch::match_against_rules</code></a> is executed.</li>
<li>The sampling algorithm will go over each <a href="struct.SamplingRule.html" title="struct relay_sampling::SamplingRule"><code>SamplingRule</code></a> and compute either a factor or
sample rate based on the <a href="enum.SamplingValue.html" title="enum relay_sampling::SamplingValue"><code>SamplingValue</code></a> of the rule.</li>
<li>The <a href="struct.SamplingMatch.html" title="struct relay_sampling::SamplingMatch"><code>SamplingMatch</code></a> is finally returned containing the final <code>sample_rate</code> and some additional
data that will be used in <code>relay_server</code> to perform the sampling decision.</li>
</ul>
<h2 id="sampling-determinism"><a href="#sampling-determinism">Sampling Determinism</a></h2>
<p>The concept of determinism is extremely important for sampling. We want to be able to make the
a deterministic sampling decision for a wide variety of reasons, including:</p>
<ul>
<li>Across a <strong>chain of Relays</strong> (e.g., we don’t want to drop an event that was retained by a previous
Relay and vice-versa).</li>
<li>Across <strong>transactions of the same trace</strong> (e.g., we want to be able to sample all the transactions
of the same trace, even though some exceptions apply).</li>
</ul>
<p>In order to perform deterministic sampling, we use the id of the event or trace as the seed
for the random number generator (e.g., all transactions with the same trace id will have the same
random number being generated). <em>Since we allow the matching of both transaction and trace rules, we might
end up in cases in which we perform inconsistent trace sampling but this is something we decided
to live with as long as there are no big implications on the product.</em></p>
<h2 id="examples"><a href="#examples">Examples</a></h2><h3 id="samplingconfig"><a href="#samplingconfig"><code>SamplingConfig</code></a></h3><div class="example-wrap"><pre class="language-json"><code>{
  &quot;rules&quot;: [],
  &quot;rulesV2&quot;: [
    {
      &quot;condition&quot;: {
        &quot;op&quot;: &quot;and&quot;,
        &quot;inner&quot;: [
          {
            &quot;op&quot;: &quot;glob&quot;,
            &quot;name&quot;: &quot;releases&quot;,
            &quot;value&quot;: [
              &quot;1.1.1&quot;,
              &quot;1.1.2&quot;
            ]
          }
        ]
      },
      &quot;samplingValue&quot;: {
        &quot;type&quot;: &quot;sampleRate&quot;,
        &quot;value&quot;: 0.7
      },
      &quot;type&quot;: &quot;transaction&quot;,
      &quot;id&quot;: 2
    },
    {
      &quot;condition&quot;: {
        &quot;op&quot;: &quot;and&quot;,
        &quot;inner&quot;: [
          {
            &quot;op&quot;: &quot;eq&quot;,
            &quot;name&quot;: &quot;transaction&quot;,
            &quot;value&quot;: &quot;/foo&quot;
          }
        ]
      },
      &quot;samplingValue&quot;: {
        &quot;type&quot;: &quot;factor&quot;,
        &quot;value&quot;: 5.0
      },
      &quot;type&quot;: &quot;trace&quot;,
      &quot;id&quot;: 1,
      &quot;timeRange&quot;: {
        &quot;start&quot;: &quot;2022-10-10T00:00:00.000000Z&quot;,
        &quot;end&quot;: &quot;2022-10-20T00:00:00.000000Z&quot;
      }
    }
  ],
  &quot;mode&quot;: &quot;total&quot;
}
</code></pre></div><h3 id="dynamicsamplingcontext"><a href="#dynamicsamplingcontext"><code>DynamicSamplingContext</code></a></h3><div class="example-wrap"><pre class="language-json"><code>{
  &quot;trace_id&quot;: &quot;00000000-0000-0000-0000-000000000000&quot;,
  &quot;public_key&quot;: &quot;abd0f232775f45feab79864e580d160b&quot;,
  &quot;release&quot;: &quot;1.0&quot;,
  &quot;environment&quot;: &quot;dev&quot;,
  &quot;transaction&quot;: &quot;/foo&quot;,
  &quot;sample_rate&quot;: &quot;0.5&quot;,
  &quot;user_id&quot;: &quot;some-id&quot;,
  &quot;user_segment&quot;: &quot;all&quot;,
  &quot;user&quot;: null
}
</code></pre></div></div></details><h2 id="structs" class="small-section-header"><a href="#structs">Structs</a></h2><ul class="item-table"><li><div class="item-name"><a class="struct" href="struct.ActiveRule.html" title="struct relay_sampling::ActiveRule">ActiveRule</a></div><div class="desc docblock-short">A sampling rule that has been successfully matched and that contains all the required data
to return the sample rate.</div></li><li><div class="item-name"><a class="struct" href="struct.AndCondition.html" title="struct relay_sampling::AndCondition">AndCondition</a></div><div class="desc docblock-short">And condition combinator.</div></li><li><div class="item-name"><a class="struct" href="struct.DynamicSamplingContext.html" title="struct relay_sampling::DynamicSamplingContext">DynamicSamplingContext</a></div><div class="desc docblock-short">DynamicSamplingContext created by the first Sentry SDK in the call chain.</div></li><li><div class="item-name"><a class="struct" href="struct.EqCondOptions.html" title="struct relay_sampling::EqCondOptions">EqCondOptions</a></div><div class="desc docblock-short">A condition that checks the values using the equality operator.</div></li><li><div class="item-name"><a class="struct" href="struct.EqCondition.html" title="struct relay_sampling::EqCondition">EqCondition</a></div><div class="desc docblock-short">A condition that checks for equality</div></li><li><div class="item-name"><a class="struct" href="struct.GlobCondition.html" title="struct relay_sampling::GlobCondition">GlobCondition</a></div><div class="desc docblock-short">A condition that uses glob matching.</div></li><li><div class="item-name"><a class="struct" href="struct.GtCondition.html" title="struct relay_sampling::GtCondition">GtCondition</a></div></li><li><div class="item-name"><a class="struct" href="struct.GteCondition.html" title="struct relay_sampling::GteCondition">GteCondition</a></div></li><li><div class="item-name"><a class="struct" href="struct.LtCondition.html" title="struct relay_sampling::LtCondition">LtCondition</a></div></li><li><div class="item-name"><a class="struct" href="struct.LteCondition.html" title="struct relay_sampling::LteCondition">LteCondition</a></div></li><li><div class="item-name"><a class="struct" href="struct.MatchedRuleIds.html" title="struct relay_sampling::MatchedRuleIds">MatchedRuleIds</a></div><div class="desc docblock-short">Represents a list of rule ids which is used for outcomes.</div></li><li><div class="item-name"><a class="struct" href="struct.NotCondition.html" title="struct relay_sampling::NotCondition">NotCondition</a></div><div class="desc docblock-short">Not condition combinator.</div></li><li><div class="item-name"><a class="struct" href="struct.OrCondition.html" title="struct relay_sampling::OrCondition">OrCondition</a></div><div class="desc docblock-short">Or condition combinator.</div></li><li><div class="item-name"><a class="struct" href="struct.RuleId.html" title="struct relay_sampling::RuleId">RuleId</a></div><div class="desc docblock-short">The id of the <a href="struct.SamplingRule.html" title="struct relay_sampling::SamplingRule"><code>SamplingRule</code></a>.</div></li><li><div class="item-name"><a class="struct" href="struct.SamplingConfig.html" title="struct relay_sampling::SamplingConfig">SamplingConfig</a></div><div class="desc docblock-short">Represents the dynamic sampling configuration available to a project.</div></li><li><div class="item-name"><a class="struct" href="struct.SamplingMatch.html" title="struct relay_sampling::SamplingMatch">SamplingMatch</a></div><div class="desc docblock-short">Represents the specification for sampling an incoming event.</div></li><li><div class="item-name"><a class="struct" href="struct.SamplingRule.html" title="struct relay_sampling::SamplingRule">SamplingRule</a></div><div class="desc docblock-short">A sampling rule as it is deserialized from the project configuration.</div></li><li><div class="item-name"><a class="struct" href="struct.TimeRange.html" title="struct relay_sampling::TimeRange">TimeRange</a></div><div class="desc docblock-short">A range of time.</div></li><li><div class="item-name"><a class="struct" href="struct.TraceUserContext.html" title="struct relay_sampling::TraceUserContext">TraceUserContext</a></div><div class="desc docblock-short">The User related information in the trace context</div></li></ul><h2 id="enums" class="small-section-header"><a href="#enums">Enums</a></h2><ul class="item-table"><li><div class="item-name"><a class="enum" href="enum.DecayingFunction.html" title="enum relay_sampling::DecayingFunction">DecayingFunction</a></div><div class="desc docblock-short">A decaying function definition.</div></li><li><div class="item-name"><a class="enum" href="enum.RuleCondition.html" title="enum relay_sampling::RuleCondition">RuleCondition</a></div><div class="desc docblock-short">A condition from a sampling rule.</div></li><li><div class="item-name"><a class="enum" href="enum.RuleType.html" title="enum relay_sampling::RuleType">RuleType</a></div><div class="desc docblock-short">Defines the type of dynamic rule, i.e. to which type of events it will be applied and how.</div></li><li><div class="item-name"><a class="enum" href="enum.SamplingMode.html" title="enum relay_sampling::SamplingMode">SamplingMode</a></div><div class="desc docblock-short">Defines which population of items a dynamic sample rate applies to.</div></li><li><div class="item-name"><a class="enum" href="enum.SamplingValue.html" title="enum relay_sampling::SamplingValue">SamplingValue</a></div><div class="desc docblock-short">A sampling strategy definition.</div></li></ul><h2 id="traits" class="small-section-header"><a href="#traits">Traits</a></h2><ul class="item-table"><li><div class="item-name"><a class="trait" href="trait.FieldValueProvider.html" title="trait relay_sampling::FieldValueProvider">FieldValueProvider</a></div><div class="desc docblock-short">Trait implemented by providers of fields (Events and Trace Contexts).</div></li></ul><h2 id="functions" class="small-section-header"><a href="#functions">Functions</a></h2><ul class="item-table"><li><div class="item-name"><a class="fn" href="fn.deserialize_bool_option.html" title="fn relay_sampling::deserialize_bool_option">deserialize_bool_option</a></div></li><li><div class="item-name"><a class="fn" href="fn.merge_configs_and_match.html" title="fn relay_sampling::merge_configs_and_match">merge_configs_and_match</a></div><div class="desc docblock-short">Gets the sampling match result by creating the merged configuration and matching it against
the sampling configuration.</div></li><li><div class="item-name"><a class="fn" href="fn.merge_rules_from_configs.html" title="fn relay_sampling::merge_rules_from_configs">merge_rules_from_configs</a></div><div class="desc docblock-short">Returns an iterator of references that chains together and merges rules.</div></li><li><div class="item-name"><a class="fn" href="fn.pseudo_random_from_uuid.html" title="fn relay_sampling::pseudo_random_from_uuid">pseudo_random_from_uuid</a></div><div class="desc docblock-short">Generates a pseudo random number by seeding the generator with the given id.</div></li></ul></section></div></main></body></html>