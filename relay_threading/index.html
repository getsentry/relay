<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="Relay Threading"><title>relay_threading - Rust</title><script>if(window.location.protocol!=="file:")document.head.insertAdjacentHTML("beforeend","SourceSerif4-Regular-6b053e98.ttf.woff2,FiraSans-Italic-81dc35de.woff2,FiraSans-Regular-0fe48ade.woff2,FiraSans-MediumItalic-ccf7e434.woff2,FiraSans-Medium-e1aa3f0a.woff2,SourceCodePro-Regular-8badfe75.ttf.woff2,SourceCodePro-Semibold-aa29a496.ttf.woff2".split(",").map(f=>`<link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/${f}">`).join(""))</script><link rel="stylesheet" href="../static.files/normalize-9960930a.css"><link rel="stylesheet" href="../static.files/rustdoc-aa0817cf.css"><meta name="rustdoc-vars" data-root-path="../" data-static-root-path="../static.files/" data-current-crate="relay_threading" data-themes="" data-resource-suffix="" data-rustdoc-version="1.90.0 (1159e78c4 2025-09-14)" data-channel="1.90.0" data-search-js="search-fa3e91e5.js" data-settings-js="settings-5514c975.js" ><script src="../static.files/storage-68b7e25d.js"></script><script defer src="../crates.js"></script><script defer src="../static.files/main-eebb9057.js"></script><noscript><link rel="stylesheet" href="../static.files/noscript-32bb7600.css"></noscript><link rel="alternate icon" type="image/png" href="../static.files/favicon-32x32-6580c154.png"><link rel="icon" type="image/svg+xml" href="../static.files/favicon-044be391.svg"></head><body class="rustdoc mod crate"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle" title="show sidebar"></button></nav><nav class="sidebar"><div class="sidebar-crate"><h2><a href="../relay_threading/index.html">relay_<wbr>threading</a><span class="version">25.9.0</span></h2></div><div class="sidebar-elems"><ul class="block"><li><a id="all-types" href="all.html">All Items</a></li></ul><section id="rustdoc-toc"><h3><a href="#">Sections</a></h3><ul class="block top-toc"><li><a href="#relay-threading" title="Relay Threading">Relay Threading</a><ul><li><a href="#concurrency-model" title="Concurrency Model">Concurrency Model</a></li><li><a href="#usage-example" title="Usage Example">Usage Example</a></li><li><a href="#error-handling" title="Error Handling">Error Handling</a></li></ul></li></ul><h3><a href="#structs">Crate Items</a></h3><ul class="block"><li><a href="#structs" title="Structs">Structs</a></li><li><a href="#traits" title="Traits">Traits</a></li></ul></section><div id="rustdoc-modnav"></div></div></nav><div class="sidebar-resizer" title="Drag to resize sidebar"></div><main><div class="width-limiter"><rustdoc-search></rustdoc-search><section id="main-content" class="content"><div class="main-heading"><h1>Crate <span>relay_threading</span><button id="copy-path" title="Copy item path to clipboard">Copy item path</button></h1><rustdoc-toolbar></rustdoc-toolbar><span class="sub-heading"><a class="src" href="../src/relay_threading/lib.rs.html#1-59">Source</a> </span></div><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><h2 id="relay-threading"><a class="doc-anchor" href="#relay-threading">§</a>Relay Threading</h2>
<p>This module provides a robust threading framework for Relay, designed to efficiently manage and execute
asynchronous workloads. At its core is a thread-based asynchronous task pool that offers:</p>
<ul>
<li><strong>Flexible Configuration</strong>: Fine-tune thread counts, naming patterns, panic handling strategies,
and concurrency limits through a builder pattern.</li>
<li><strong>Task Multiplexing</strong>: Distribute tasks across dedicated worker threads.</li>
<li><strong>Panic Recovery</strong>: Built-in mechanisms to gracefully handle and recover from panics, both at the
thread and individual task level</li>
<li><strong>Tokio Integration</strong>: Seamlessly integrates with Tokio runtime for async task execution</li>
</ul>
<h3 id="concurrency-model"><a class="doc-anchor" href="#concurrency-model">§</a>Concurrency Model</h3>
<p>The pool maintains a set of dedicated worker threads, each capable of executing multiple async tasks
concurrently up to a configurable limit. This architecture ensures efficient resource utilization
while preventing any single thread from becoming overwhelmed.</p>
<p>The pool maintains a bounded queue with a capacity of twice the number of worker threads. This
design allows new tasks to be queued while existing ones are being processed, ensuring smooth
task handoff between producers and consumers. The bounded nature of the queue provides natural
backpressure - when workers are overwhelmed, task submission will block until capacity becomes
available, preventing resource exhaustion.</p>
<h3 id="usage-example"><a class="doc-anchor" href="#usage-example">§</a>Usage Example</h3>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>relay_threading::{AsyncPoolBuilder, AsyncPool};
<span class="kw">use </span>tokio::runtime::Runtime;

<span class="comment">// Create a runtime (for example purposes, create one inline)
</span><span class="kw">let </span>runtime_handle = Runtime::new().unwrap();

<span class="comment">// Build an async pool with 4 threads and a max of 100 concurrent tasks per thread
</span><span class="kw">let </span>pool: AsyncPool&lt;<span class="kw">_</span>&gt; = AsyncPoolBuilder::new(runtime_handle.handle().clone())
    .num_threads(<span class="number">4</span>)
    .max_concurrency(<span class="number">100</span>)
    .build()
    .expect(<span class="string">"Failed to build async pool"</span>);

<span class="comment">// Schedule a task to be executed by the pool
</span>pool.spawn(<span class="kw">async </span>{
    <span class="comment">// Place your asynchronous task logic here
</span>});</code></pre></div>
<h3 id="error-handling"><a class="doc-anchor" href="#error-handling">§</a>Error Handling</h3>
<p>Both the async pool and its task multiplexer support custom panic handlers, allowing graceful
recovery from panics in either thread execution or individual tasks.</p>
</div></details><h2 id="structs" class="section-header">Structs<a href="#structs" class="anchor">§</a></h2><dl class="item-table"><dt><a class="struct" href="struct.AsyncPool.html" title="struct relay_threading::AsyncPool">Async<wbr>Pool</a></dt><dd><a href="struct.AsyncPool.html" title="struct relay_threading::AsyncPool"><code>AsyncPool</code></a> is a thread-based executor that runs asynchronous tasks on dedicated worker threads.</dd><dt><a class="struct" href="struct.AsyncPoolBuilder.html" title="struct relay_threading::AsyncPoolBuilder">Async<wbr>Pool<wbr>Builder</a></dt><dd><a href="struct.AsyncPoolBuilder.html" title="struct relay_threading::AsyncPoolBuilder"><code>AsyncPoolBuilder</code></a> provides a flexible way to configure and build an <a href="struct.AsyncPool.html" title="struct relay_threading::AsyncPool"><code>AsyncPool</code></a> for executing
asynchronous tasks concurrently on dedicated threads.</dd><dt><a class="struct" href="struct.AsyncPoolMetrics.html" title="struct relay_threading::AsyncPoolMetrics">Async<wbr>Pool<wbr>Metrics</a></dt><dd>Metrics for the asynchronous pool.</dd><dt><a class="struct" href="struct.CustomSpawn.html" title="struct relay_threading::CustomSpawn">Custom<wbr>Spawn</a></dt><dd><a href="struct.CustomSpawn.html" title="struct relay_threading::CustomSpawn"><code>CustomSpawn</code></a> is an alternative implementation of <a href="trait.ThreadSpawn.html" title="trait relay_threading::ThreadSpawn"><code>ThreadSpawn</code></a> that uses a user-supplied closure
for custom thread configuration.</dd><dt><a class="struct" href="struct.DefaultSpawn.html" title="struct relay_threading::DefaultSpawn">Default<wbr>Spawn</a></dt><dd><a href="struct.DefaultSpawn.html" title="struct relay_threading::DefaultSpawn"><code>DefaultSpawn</code></a> is the default implementation of <a href="trait.ThreadSpawn.html" title="trait relay_threading::ThreadSpawn"><code>ThreadSpawn</code></a> that delegates to the system’s
standard thread creation mechanism.</dd><dt><a class="struct" href="struct.Thread.html" title="struct relay_threading::Thread">Thread</a></dt><dd><a href="struct.Thread.html" title="struct relay_threading::Thread"><code>Thread</code></a> represents a dedicated worker thread within an <a href="struct.AsyncPool.html" title="struct relay_threading::AsyncPool"><code>AsyncPool</code></a> that executes scheduled tasks.</dd></dl><h2 id="traits" class="section-header">Traits<a href="#traits" class="anchor">§</a></h2><dl class="item-table"><dt><a class="trait" href="trait.ThreadSpawn.html" title="trait relay_threading::ThreadSpawn">Thread<wbr>Spawn</a></dt><dd><a href="trait.ThreadSpawn.html" title="trait relay_threading::ThreadSpawn"><code>ThreadSpawn</code></a> defines how threads are spawned in an <a href="struct.AsyncPool.html" title="struct relay_threading::AsyncPool"><code>AsyncPool</code></a>.</dd></dl></section></div></main></body></html>