<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="Utilities for error handling in FFI bindings."><title>relay_ffi - Rust</title><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/SourceSerif4-Regular-46f98efaafac5295.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/FiraSans-Regular-018c141bf0843ffd.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/FiraSans-Medium-8f9a781e4970d388.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/SourceCodePro-Regular-562dcc5011b6de7d.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/SourceSerif4-Bold-a2c9cd1067f8b328.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/SourceCodePro-Semibold-d899c5a5c4aeb14a.ttf.woff2"><link rel="stylesheet" href="../static.files/normalize-76eba96aa4d2e634.css"><link rel="stylesheet" href="../static.files/rustdoc-cb6f1f67f1bcd037.css" id="mainThemeStyle"><meta name="rustdoc-vars" data-root-path="../" data-static-root-path="../static.files/" data-current-crate="relay_ffi" data-themes="" data-resource-suffix="" data-rustdoc-version="1.73.0 (cc66ad468 2023-10-03)" data-channel="1.73.0" data-search-js="search-6dfdfced5eff6596.js" data-settings-js="settings-de11bff964e9d4e5.js" data-settings-css="settings-8c76f75bfb6bd192.css" data-theme-light-css="light-1596385f77d47ef2.css" data-theme-dark-css="dark-0a43001d3fc2282c.css" data-theme-ayu-css="ayu-fd19013d6ce078bf.css" ><script src="../static.files/storage-db41da1a38ea3cb8.js"></script><script defer src="../crates.js"></script><script defer src="../static.files/main-0795b7d26be81095.js"></script><noscript><link rel="stylesheet" media="(prefers-color-scheme:light)" href="../static.files/light-1596385f77d47ef2.css"><link rel="stylesheet" media="(prefers-color-scheme:dark)" href="../static.files/dark-0a43001d3fc2282c.css"><link rel="stylesheet" href="../static.files/noscript-cffde32267a19fd6.css"></noscript><link rel="icon" href="https://raw.githubusercontent.com/getsentry/relay/master/artwork/relay-icon.png"></head><body class="rustdoc mod crate"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle">&#9776;</button><a class="logo-container" href="../relay_ffi/index.html"><img src="https://raw.githubusercontent.com/getsentry/relay/master/artwork/relay-icon.png" alt="logo"></a><h2></h2></nav><nav class="sidebar"><a class="logo-container" href="../relay_ffi/index.html"><img src="https://raw.githubusercontent.com/getsentry/relay/master/artwork/relay-icon.png" alt="logo"></a><h2 class="location"><a href="#">Crate relay_ffi</a></h2><div class="sidebar-elems"><ul class="block"><li class="version">Version 23.10.1</li><li><a id="all-types" href="all.html">All Items</a></li></ul><section><ul class="block"><li><a href="#structs">Structs</a></li><li><a href="#functions">Functions</a></li><li><a href="#attributes">Attribute Macros</a></li></ul></section></div></nav><main><div class="width-limiter"><nav class="sub"><form class="search-form"><span></span><input class="search-input" name="search" aria-label="Run search in the documentation" autocomplete="off" spellcheck="false" placeholder="Click or press ‘S’ to search, ‘?’ for more options…" type="search"><div id="help-button" title="help" tabindex="-1"><a href="../help.html">?</a></div><div id="settings-menu" tabindex="-1"><a href="../settings.html" title="settings"><img width="22" height="22" alt="Change settings" src="../static.files/wheel-7b819b6101059cd0.svg"></a></div></form></nav><section id="main-content" class="content"><div class="main-heading"><h1>Crate <a class="mod" href="#">relay_ffi</a><button id="copy-path" title="Copy item path to clipboard"><img src="../static.files/clipboard-7571035ce49a181d.svg" width="19" height="18" alt="Copy item path"></button></h1><span class="out-of-band"><a class="src" href="../src/relay_ffi/lib.rs.html#1-289">source</a> · <button id="toggle-all-docs" title="collapse all docs">[<span>&#x2212;</span>]</button></span></div><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>Utilities for error handling in FFI bindings.</p>
<p>This crate facilitates an <a href="https://man7.org/linux/man-pages/man3/errno.3.html"><code>errno</code></a>-like error handling pattern: On success, the result of a
function call is returned. On error, a thread-local marker is set that allows to retrieve the
error, message, and a backtrace if available.</p>
<h2 id="catch-errors-and-panics"><a href="#catch-errors-and-panics">Catch Errors and Panics</a></h2>
<p>The <a href="attr.catch_unwind.html" title="attr relay_ffi::catch_unwind"><code>catch_unwind</code></a> attribute annotates functions that can internally throw errors. It allows
the use of the questionmark operator <code>?</code> in a function that does not return <code>Result</code>. The error
is then available using <a href="fn.with_last_error.html" title="fn relay_ffi::with_last_error"><code>with_last_error</code></a>:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>relay_ffi::catch_unwind;

<span class="attr">#[catch_unwind]
</span><span class="kw">unsafe fn </span>parse_number() -&gt; i32 {
    <span class="comment">// use the questionmark operator for errors:
    </span><span class="kw">let </span>number: i32 = <span class="string">&quot;42&quot;</span>.parse()<span class="question-mark">?</span>;

    <span class="comment">// return the value directly, not `Ok`:
    </span>number * <span class="number">2
</span>}</code></pre></div>
<h2 id="safety"><a href="#safety">Safety</a></h2>
<p>Since function calls always need to return a value, this crate has to return
<code>std::mem::zeroed()</code> as a placeholder in case of an error. This is unsafe for reference types
and function pointers. Because of this, functions must be marked <code>unsafe</code>.</p>
<p>In most cases, FFI functions should return either <code>repr(C)</code> structs or pointers, in which case
this is safe in principle. The author of the API is responsible for defining the contract,
however, and document the behavior of custom structures in case of an error.</p>
<h2 id="examples"><a href="#examples">Examples</a></h2>
<p>Annotate FFI functions with <a href="attr.catch_unwind.html" title="attr relay_ffi::catch_unwind"><code>catch_unwind</code></a> to capture errors. The error can be inspected via
<a href="fn.with_last_error.html" title="fn relay_ffi::with_last_error"><code>with_last_error</code></a>:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>relay_ffi::{catch_unwind, with_last_error};

<span class="attr">#[catch_unwind]
</span><span class="kw">unsafe fn </span>parse_number() -&gt; i32 {
    <span class="string">&quot;42&quot;</span>.parse()<span class="question-mark">?
</span>}

<span class="kw">let </span>parsed = <span class="kw">unsafe </span>{ parse_number() };
<span class="kw">match </span>with_last_error(|e| e.to_string()) {
    <span class="prelude-val">Some</span>(error) =&gt; <span class="macro">println!</span>(<span class="string">&quot;errored with: {error}&quot;</span>),
    <span class="prelude-val">None </span>=&gt; <span class="macro">println!</span>(<span class="string">&quot;result: {parsed}&quot;</span>),
}</code></pre></div>
<p>To capture panics, register the panic hook early during library initialization:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>relay_ffi::{catch_unwind, with_last_error};

relay_ffi::set_panic_hook();

<span class="attr">#[catch_unwind]
</span><span class="kw">unsafe fn </span>fail() {
    <span class="macro">panic!</span>(<span class="string">&quot;expected panic&quot;</span>);
}

<span class="kw">unsafe </span>{ fail() };

<span class="kw">if let </span><span class="prelude-val">Some</span>(description) = with_last_error(|e| e.to_string()) {
    <span class="macro">println!</span>(<span class="string">&quot;{description}&quot;</span>);
}</code></pre></div>
<h2 id="creating-c-apis"><a href="#creating-c-apis">Creating C-APIs</a></h2>
<p>This is an example for exposing an API to C:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>std::ffi::CString;
<span class="kw">use </span>std::os::raw::c_char;

<span class="attr">#[no_mangle]
</span><span class="kw">pub unsafe extern </span><span class="string">&quot;C&quot; </span><span class="kw">fn </span>init_ffi() {
    relay_ffi::set_panic_hook();
}

<span class="attr">#[no_mangle]
</span><span class="kw">pub unsafe extern </span><span class="string">&quot;C&quot; </span><span class="kw">fn </span>last_strerror() -&gt; <span class="kw-2">*mut </span>c_char {
    <span class="kw">let </span>ptr_opt = relay_ffi::with_last_error(|err| {
        CString::new(err.to_string())
            .unwrap_or_default()
            .into_raw()
    });

    ptr_opt.unwrap_or(std::ptr::null_mut())
}</code></pre></div>
</div></details><h2 id="structs" class="small-section-header"><a href="#structs">Structs</a></h2><ul class="item-table"><li><div class="item-name"><a class="struct" href="struct.Panic.html" title="struct relay_ffi::Panic">Panic</a></div><div class="desc docblock-short">An error representing a panic carrying the message as payload.</div></li></ul><h2 id="functions" class="small-section-header"><a href="#functions">Functions</a></h2><ul class="item-table"><li><div class="item-name"><a class="fn" href="fn.set_panic_hook.html" title="fn relay_ffi::set_panic_hook">set_panic_hook</a></div><div class="desc docblock-short">Registers a hook for capturing panics with backtraces.</div></li><li><div class="item-name"><a class="fn" href="fn.take_last_error.html" title="fn relay_ffi::take_last_error">take_last_error</a></div><div class="desc docblock-short">Takes the last error, leaving <code>None</code> in its place.</div></li><li><div class="item-name"><a class="fn" href="fn.with_last_error.html" title="fn relay_ffi::with_last_error">with_last_error</a></div><div class="desc docblock-short">Acquires a reference to the last error and passes it to the callback, if any.</div></li></ul><h2 id="attributes" class="small-section-header"><a href="#attributes">Attribute Macros</a></h2><ul class="item-table"><li><div class="item-name"><a class="attr" href="attr.catch_unwind.html" title="attr relay_ffi::catch_unwind">catch_unwind</a></div><div class="desc docblock-short">Captures errors and panics in a thread-local on <code>unsafe</code> functions.</div></li></ul></section></div></main></body></html>